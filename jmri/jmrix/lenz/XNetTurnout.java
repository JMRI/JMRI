/**
 * XNetTurnout.java
 *
 * Description:		extend jmri.AbstractTurnout for XNet layouts
 * <P>
 * Turnout opperation on XPressNet based systems goes through the 
 * following sequence:
 * <UL>
 * <LI> set the commanded state, and, Send request to command station to 
 *      start sending DCC operations packet to track</LI>
 * <LI> Wait for response message from command station.  (valid response 
 *      list follows)</LI>
 * <LI> Send request to command station to stop sending DCC operations
 *      packet to track</LI>
 * <LI> Wait for response from command station
 *      <UL> 
 *       <LI>If Success Message, set Known State to Commanded State</LI>
 *       <LI>If error message, repeat previous step</LI>
 *      </UL>
 * </LI>
 * </UL>
 * <P>
 * NOTE: Some XPressNet Command stations take no action when the message 
 * generated durring the third step is received
 * <P>
 * Valid response messages are command station dependent,  but there are 
 * 4 possibilities:
 * <UL>
 * <LI> a "Command Successfully Recieved..." (aka "OK") message</LI>
 * <LI> a "Feedback Response Message" indicating the message is for a 
 *      turnout with feedback</LI>
 * <LI> a "Feedback Response Message" indicating the message is for a 
 *      turnout without feedback</LI>
 * <LI> The XPressNet protocol allows for no response. </LI>
 * </UL>
 * <P>
 * Response NOTE 1: The "Command Successfully Received..." message is 
 * generated by the lenz LIxxx interfaces when it successfully transfers 
 * the command to the command station.  When this happens, the command 
 * station generates no useable response message.
 * <P>
 * Response NOTE 2: Currently the only command stations known to generate
 * Feedback response messages are the Lenz LZ100 and LZV100.
 * <P>
 * Response NOTE 3: Software version 3.2 and above LZ100 and LZV100 may 
 * send either a Feedback response or no response at all.  All other 
 * known command stations generate no response.
 * <P>
 * Response NOTE 4: The Feedback response messages may be generated 
 * asynchronously 
 * <P>
 * Response NOTE 5: Feedback response messages may contain feedback for more
 * than one device.  The devices included in the response may or may not 
 * be stationary decoders (they can also be feedback encoders see 
 * {@link XNetSensor}).
 * <P>
 * Response NOTE 6: The last situation situation is not currently handled.
 * The supported interfaces garantee at least an "OK" message will be sent 
 * to the computer
 * <P>
 * What is done with each of the response messages depends on which 
 * feedback mode is in use.  "DIRECT,"MONITORING", and "EXACT" feedback 
 * mode are supported directly by this class.  
 * <P>
 * "DIRECT" mode instantly triggers step 3 when any valid response 
 * message for this turnout is recieved from the command station or 
 * computer interface.
 * <P>
 * "MONITORING" mode is an extention to direct mode. In monitoring mode, 
 * a feedback response message (for a turnout with or without feedback)
 * is interpreted to set the known state of the turnout based on  
 * information provided by the command station.
 * <P>
 * "MONITORING" mode will interpret the feedback response messages when 
 * they are generated by external sources (fascia controls or other 
 * XPressNet devices) and that information is recieved by the computer.
 * <P>
 * "EXACT" mode is an extention of "MONITORING" mode.  In addition to 
 * interpretting all feedback messages from the command station, "EXACT" 
 * mode will monitor the "motion complete" bit of the feedback response.
 * <P>
 * For turnouts without feedback, the motion complete bit is always set,
 * so "EXACT" mode handles these messages as though the specified feedback 
 * mode is "MONITORING" mode.
 * <P>
 * For turnouts with feedback, "EXACT" mode polls the command station 
 * until the motion complete bit is set before triggering step 3 of the 
 * turnout operation sequence.
 * <P>
 * "EXACT" mode will interpret the feedback response messages when 
 * they are generated by external sources (fascia controls or other 
 * XPressNet devices) and that information is recieved by the computer.
 * <P> 
 * NOTE: For LZ100 and LZV100 command stations prior to version 3.2, it 
 * may be necessary to poll for the feedback response data.
 * </P>
 * @author			Bob Jacobsen Copyright (C) 2001, Portions by Paul Bender Copyright (C) 2003 
 * @version			$Revision: 2.6 $
 */

package jmri.jmrix.lenz;

import jmri.AbstractTurnout;

public class XNetTurnout extends AbstractTurnout implements XNetListener {

    /* State information */
    static final int OFFSENT = 1;
    static final int IDLE = 0;
    private int InternalState = IDLE;

    /* Static arrays to hold Lenz specific feedback mode information */
    static String[] modeNames = null;
    static int[] modeValues = null;

    public XNetTurnout(int pNumber) {  // a human-readable turnout number must be specified!
        super("XT"+pNumber);
        mNumber = pNumber;

        /* Add additiona feedback types information */
	_validFeedbackTypes |= MONITORING | EXACT;

	// Default feedback mode is MONITORING
	_activeFeedbackType = MONITORING;

	// if it hasn't been done already, create static arrays to hold 
        // the Lenz specific feedback information.
	if(modeNames == null) {
           if (_validFeedbackNames.length != _validFeedbackModes.length)
                log.error("int and string feedback arrays different length");
           modeNames  = new String[_validFeedbackNames.length+2];  
           modeValues = new int[_validFeedbackNames.length+2];
           for (int i = 0; i<_validFeedbackNames.length; i++) {
               modeNames[i] = _validFeedbackNames[i];
               modeValues[i] = _validFeedbackModes[i];
           }
           modeNames[_validFeedbackNames.length] = "MONITORING";
           modeValues[_validFeedbackNames.length] = MONITORING;
           modeNames[_validFeedbackNames.length+1] = "EXACT";
           modeValues[_validFeedbackNames.length+1] = EXACT;  
        }

        // set the mode names and values based on the static values.
        _validFeedbackNames = modeNames;
        _validFeedbackModes = modeValues;

        // At construction, register for messages
        XNetTrafficController.instance().addXNetListener(XNetInterface.FEEDBACK|XNetInterface.COMMINFO, this);
	// And to get property change information from the superclass
	_stateListener=new XNetTurnoutStateListener(this);
	this.addPropertyChangeListener(_stateListener);
	// Finally, request the current state from the layout.
    	requestUpdateFromLayout();
    }

    public int getNumber() { return mNumber; }

    // Set the Commanded State.   This method overides setCommandedState in 
    // the Abstract Turnout class.
    synchronized public void setCommandedState(int s){
	forwardCommandChangeToLayout(s);
	newCommandedState(s);
	newKnownState(INCONSISTENT);
    }   

    // Handle a request to change state by sending an XPressNet command
    synchronized protected void forwardCommandChangeToLayout(int s) {
        // find the command station
        LenzCommandStation cs = XNetTrafficController.instance().getCommandStation();
        // get the right packet
        XNetMessage msg = XNetMessage.getTurnoutCommandMsg(mNumber,
                                                  (s & CLOSED)!=0,
                                                  (s & THROWN)!=0,
                                                  true );

        XNetTrafficController.instance().sendXNetMessage(msg, this);
    }

    /**
     * request an update on status by sending an XPressNet message
     */
    public void requestUpdateFromLayout() {
       // To do this, we send an XpressNet Accessory Decoder Information
       // Request.
       // The generated message works for Feedback modules and turnouts
       // with feedback, but the address passed is translated as though it
       // is a turnout address.  As a result, we substitute our base
       // address in for the address. after the message is returned.
       XNetMessage msg = XNetMessage.getFeedbackRequestMsg(mNumber,
                                                 (mNumber%4)<2); 
       XNetTrafficController.instance().sendXNetMessage(msg, this);
    }


    /*
     *  Handle an incoming message from the XPressNet
     */
    synchronized public void message(XNetReply l) {
	if(log.isDebugEnabled()) log.debug("recieved message: " +l);
        if(InternalState==OFFSENT) {
	  // If an OFF was sent, we want to check for Communications 
          // errors before we try to do anything else. 
	  if(l.isCommErrorMessage()) {
            /* this is a communications error */
            log.error("Communications error occured - message recieved was: " + l);
	    sendOffMessage();
            return;
	  } else  if(l.isCSBusyMessage()) {
            /* this is a communications error */
            log.error("Command station busy - message recieved was: " + l);
	    sendOffMessage();
            return;
	  } else if(l.isOkMessage()) {
	    /* the command was successfully recieved */
	    newKnownState(getCommandedState());
	    InternalState=IDLE;
	    return;
	  }
        }

	switch(getFeedbackMode()) {
	    case EXACT:
		handleMonitoringModeFeedback(l);
		break;
	    case MONITORING:
		handleMonitoringModeFeedback(l);
		break;
            case DIRECT:
	    default:
		// Default is direct mode
		handleDirectModeFeedback(l);
        }
    }

    // listen for the messages to the LI100/LI101
    public void message(XNetMessage l) {
    }


    /*
     *  With Direct Mode feedback, if we see ANY valid response to our
     *  request, we ask the command station to stop sending information 
     *  to the stationary decoder.
     *  <p>
     *  No effort is made to interpret feedback when using direct mode
     *
     *  @param l an {@link XNetReply} message
     *
     */ 
    synchronized private void handleDirectModeFeedback(XNetReply l) {
       /* If commanded state does not equal known state, we are 
          going to check to see if one of the following conditions 
	  applies:
	  1) The recieved message is a feedback message for a turnout
             and one of the two addresses to which it applies is our 
             address
          2) We recieve an "OK" message, indicating the command was 
	     successfully sent
           
          If either of these two cases occur, we trigger an off message
       */

       if(log.isDebugEnabled()) log.debug("Handle Message for turnout " + 
	  mNumber + " in DIRECT feedback mode ");
       if(getCommandedState()!=getKnownState()) {
          if(l.isFeedbackBroadcastMessage()) {
	     int numDataBytes=l.getElement(0)&0x0f;
	     for(int i=1;i<numDataBytes;i+=2) {
                int messageType= l.getFeedbackMessageType(i);
	        if(messageType==0 || messageType == 1) {
                   if ((mNumber%2==1 && 
                       (l.getTurnoutMsgAddr(i) == mNumber)) ||
                      (((mNumber%2)==0) && 
                       (l.getTurnoutMsgAddr(i) == mNumber-1))) {
		      // This message includes feedback for this turnout  
		      sendOffMessage();
		      break;
                   }
                }  
             }     
          } else if(l.isOkMessage()) {
             // Finally, we may just recieve an OK message.
	     sendOffMessage();
	  } else return;
       }
    }

    /*
     *  With Monitoring Mode feedback, if we see a feedback message, we 
     *  interpret that message and use it to display our feedback. 
     *  <P> 
     *  After we send a request to operate a turnout, We ask the command 
     *  station to stop sending information to the stationary decoder
     *  when the either a feedback message or an "OK" message is recieved.
     *
     *  @param l an {@link XNetReply} message
     *
     */ 
    synchronized private void handleMonitoringModeFeedback(XNetReply l){
       /* In Monitoring Mode, We have two cases to check if CommandedState 
          does not equal KnownState, otherwise, we only want to check to 
	  see if the messages we recieve indicate this turnout chagned 
          state
       */
       if(log.isDebugEnabled()) log.debug("Handle Message for turnout " + 
	                   mNumber + " in MONITORING feedback mode "); 
       if(getCommandedState()==getKnownState()) {
	  if(l.isFeedbackBroadcastMessage()) {
             // This is a feedback message, we need to check and see if it
             // indicates this turnout is to change state or if it is for 
             // another turnout.
	     int numDataBytes=l.getElement(0)&0x0f;
	     for(int i=1;i<numDataBytes;i+=2) {
	        if(parseFeedbackMessage(l,i)!=-1)
	           break;
             }
          }
       } else {
	  // getCommandedState()!=getKnownState()
          if(l.isFeedbackBroadcastMessage()) {
	     int numDataBytes=l.getElement(0)&0x0f;
	     for(int i=1;i<numDataBytes;i+=2) {
                int messageType= l.getFeedbackMessageType(i);
	        if(messageType==0 || messageType == 1) {
	           // In Monitoring mode, treat both turnouts with feedback 
                   // and turnouts without feedback as turnouts without 
                   // feedback.  i.e. just interpret the feedback 
                   // message, don't check to see if the motion is complete
	           if(parseFeedbackMessage(l,i)!=-1) {
                   // We need to tell the turnout to shut off the output.
	              sendOffMessage();
                      break;
                   }
                }
             }       
	  } else if (l.isOkMessage()) {
             // Finally, we may just recieve an OK message.
	     sendOffMessage();
          } else return;
       }
    }
   

    /*
     *  With Exact Mode feedback, if we see a feedback message, we 
     *  interpret that message and use it to display our feedback. 
     *  <P> 
     *  After we send a request to operate a turnout, We ask the command 
     *  station to stop sending information to the stationary decoder
     *  when the either a feedback message or an "OK" message is recieved.
     *
     *  @param l an {@link XNetReply} message
     *
     */ 
    synchronized private void handleExactModeFeedback(XNetReply l) {
       // We have three cases to check if CommandedState does 
       // not equal KnownState, otherwise, we only want to check to 
       // see if the messages we recieve indicate this turnout chagned 
       // state
       if(log.isDebugEnabled()) log.debug("Handle Message for turnout " + 
				mNumber + " in EXACT feedback mode "); 
       if(getCommandedState()==getKnownState()) {
          if(l.isFeedbackBroadcastMessage()) {
             // This is a feedback message, we need to check and see if it
             // indicates this turnout is to change state or if it is for 
             // another turnout.
	     int numDataBytes=l.getElement(0)&0x0f;
	     for(int i=1;i<numDataBytes;i+=2) {
	        if(parseFeedbackMessage(l,i)!=-1)
                   break;
                }
             }
       } else {
          // getCommandedState()!=getKnownState()
          if(l.isFeedbackBroadcastMessage()) {
             int numDataBytes=l.getElement(0)&0x0f;
             for(int i=1;i<numDataBytes;i+=2) {
                if ((mNumber%2==1 && 
                    (l.getTurnoutMsgAddr(i) == mNumber)) ||
                   (((mNumber%2)==0) && 
                    (l.getTurnoutMsgAddr(i) == mNumber-1))) {
		   // This message includes feedback for this turnout  
                   int messageType= l.getFeedbackMessageType(i);
	           if(messageType == 1) {
	              // The first case is that we recieve a message for 
                      // this turnout and this turnout provides feedback.
                      // In this case, we want to check to see if the 
                      // turnout has completed it's movement before doing 
                      // anything else.
	              if(!motionComplete(l,i)) {
                         // If the motion is NOT complete, send a feedback 
                         // request for this nibble
                         XNetMessage msg = XNetMessage.getFeedbackRequestMsg(
                                            mNumber, ((mNumber%4)<=1));
                         XNetTrafficController.instance()
                                            .sendXNetMessage(msg, this);
                      } else {
                         // If the motion is completed, behave as though 
                         // this is a turnout without feedback.
	                 parseFeedbackMessage(l,i);
                         // We need to tell the turnout to shut off the 
                         // output.
	                 sendOffMessage();
                      }       
                   } else if (messageType == 0) {
                     // The second case is that we recieve a message about
                     // this turnout, and this turnout does not provide 
                     // feedback. In this case, we want to check the 
                     // contents of the message and act accordingly.
	             parseFeedbackMessage(l,i);
                     // We need to tell the turnout to shut off the output.
	             sendOffMessage();
                   }
                   break;
                }
             }
	  } else if (l.isOkMessage()) {
             // Finally, we may just recieve an OK message.
	     sendOffMessage();
	  } else return;
       }
    }

    /* Send an "Off" message to the decoder for this output  */
    synchronized private void sendOffMessage() {
            // We need to tell the turnout to shut off the output.
            XNetMessage msg =  XNetMessage.getTurnoutCommandMsg(mNumber,
                                                  getCommandedState()==CLOSED,
                                                  getCommandedState()==THROWN,
                                                  false );
            XNetTrafficController.instance().sendXNetMessage(msg, this);
	    // Set the known state to the commanded state.
	    newKnownState(getCommandedState());
	    InternalState = OFFSENT;
    }




     /*
      * parse the feedback message, and set the status of the turnout 
      * accordingly
      *
      * @param l - feedback broadcast message
      * @param startByte - first Byte of message to check
      * 
      * @return 0 if address matches our turnout -1 otherwise
      */
     synchronized private int parseFeedbackMessage(XNetReply l,int startByte) {
        // check validity & addressing
        // if this is an ODD numbered turnout, then we always get the 
        // right response from .getTurnoutMsgAddr.  If this is an even 
        // numbered turnout, we need to check the messages for the odd 
        // numbered turnout in the nibble as well.
        if (mNumber%2==1 && (l.getTurnoutMsgAddr(startByte) == mNumber)) {
            // is for this object, parse the message
            if (log.isDebugEnabled()) log.debug("Message for turnout" + mNumber);
            if(l.getTurnoutStatus(startByte,1)==THROWN) {
               newCommandedState(THROWN);
               newKnownState(getCommandedState());
	       return(0);
            } else if(l.getTurnoutStatus(startByte,1)==CLOSED) { 
               newCommandedState(CLOSED);
               newKnownState(getCommandedState());
	       return(0);
            } else return -1;
        } else if (((mNumber%2)==0) && 
                   (l.getTurnoutMsgAddr(startByte) == mNumber-1)) {
            // is for this object, parse message type
            if (log.isDebugEnabled()) log.debug("Message for turnout" + mNumber);
            if(l.getTurnoutStatus(startByte,0)==THROWN) {
               newCommandedState(THROWN);
               newKnownState(getCommandedState());
	       return(0);
            } else if(l.getTurnoutStatus(startByte,0)==CLOSED) { 
               newCommandedState(CLOSED);
               newKnownState(getCommandedState());
	       return(0);
            } else return -1;
        }    
       return(-1);
    }


     /*
      * Determine if this feedback message says the turnout has completed 
      * it's motion or not.  Returns true for mostion complete, false 
      * otherwise. 
      *
      * @param l - feedback broadcast message
      * @param startByte - first Byte of message to check
      * 
      * @return true if motion complete, false otherwise
      */
     synchronized private boolean motionComplete(XNetReply l,int startByte) {
        // check validity & addressing
        // if this is an ODD numbered turnout, then we always get the 
        // right response from .getTurnoutMsgAddr.  If this is an even 
        // numbered turnout, we need to check the messages for the odd 
        // numbered turnout in the nibble as well.
        if (mNumber%2==1 && (l.getTurnoutMsgAddr(startByte) == mNumber)) {
            // is for this object, parse the message
            int messageType= l.getFeedbackMessageType(startByte);
	  if(messageType == 1) {
             int a2=l.getElement(startByte+1);
             if((a2 & 0x80)==0x80) { return false;
             } else { return true; }
	  } else return false;
        } else if (((mNumber%2)==0) && 
                   (l.getTurnoutMsgAddr(startByte) == mNumber-1)) {
            // is for this object, parse the message
          int messageType= l.getFeedbackMessageType(startByte);
	  if(messageType == 1) {
             int a2=l.getElement(startByte+1);
             if((a2&0x80)==0x80) { return false;
             } else { return true; }
	  } else return false;            
        }    
       return(false);
    }

    public void dispose() {
        XNetTrafficController.instance().removeXNetListener(
			XNetInterface.FEEDBACK|XNetInterface.COMMINFO, this);
	this.removePropertyChangeListener(_stateListener);
    }

   
    // Internal class to use for listening to state changes
    private class XNetTurnoutStateListener implements java.beans.PropertyChangeListener {

    XNetTurnout _turnout=null;

    XNetTurnoutStateListener(XNetTurnout turnout){
	_turnout=turnout;
    }

    /*
     * If we're  not using DIRECT feedback mode, we need to listen for 
     * state changes to know when to send an OFF message after we set the 
     * known state
     * If we're using DIRECT mode, all of this is handled from the 
     * XPressNet Messages
     */
    public void propertyChange(java.beans.PropertyChangeEvent event) {
	if(log.isDebugEnabled()) log.debug("propertyChange called");
	// If we're using DIRECT feedback mode, we don't care what we see here
	if(_turnout.getFeedbackMode()!=DIRECT) {
	   if(event.getPropertyName().equals("KnownState")) {
		// Check to see if this is a change in the status 
		// triggered by a device on the layout, or a change in 
		// status we triggered.
		int oldKnownState=((Integer)event.getOldValue()).intValue();
		int curKnownState=((Integer)event.getNewValue()).intValue();
		if(_turnout.getCommandedState()==oldKnownState) {
		   // This was triggered by feedback on the layout, change 
		   // the commanded state to reflect the new Known State
               	   _turnout.newCommandedState(curKnownState);
		} else {
		   // Since we always set the KnownState to 
		   // INCONSISTENT when we send a command, If the old 
		   // known state is INCONSISTENT, we just want to send 
                   // an off message
		   if(oldKnownState==INCONSISTENT){
		   	_turnout.sendOffMessage();
		   }
		}
	    }
	}	
    }
    
    }

    // data members
    int mNumber;   // XPressNet turnout number
    XNetTurnoutStateListener _stateListener;  // Internal class object

    static org.apache.log4j.Category log = org.apache.log4j.Category.getInstance(XNetTurnout.class.getName());

}


/* @(#)XNetTurnout.java */

