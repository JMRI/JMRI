<!DOCTYPE html>
<html lang="en">

<head>
  <title>JMRI: LogixNG Documentation</title>
  <meta name="author" content="David Duchamp">
  <meta name="author" content="Daniel Bergqvist">
  <meta name="author" content="Dave Sand">
  <meta name="keywords" content="java model railroad JMRI LogixNG">

  <!--#include virtual="/Style.shtml" -->

</head>

<body>
  <!--#include virtual="/Header.shtml" -->

  <div id="mBody">
    <!--#include virtual="Sidebar" -->

    <div id="mainContent">
      <h1><a id="TopOfPage" name="TopOfPage"></a>JMRI: LogixNG Documentation</h1>

<a href="Tutorial/index.shtml">Tutorial</a>

      <p class="noted">LogixNG, along with its documentation, is still evolving.
      Some of the text is based on the original Logix documents.</p>

      <p>JMRI has for a long time had the tool Logix which can be
      used to create rules, for example that a signal should go to
      green if some turnouts are in a predefined state. Logix does
      its job well, but is difficult to extend with new functionality.</p>

      <p>LogixNG, short for Logix Next Generation, is a complete
      rethink of the concept. It's modular, which means
      it's easy to extend LogixNG with new functionality and it's
      easy to test each part of LogixNG.</p>

      <p>LogixNG have building blocks that are similar to Logix.
      A <i>LogixNG</i> is the same as a <i>Logix</i>. A
      <i>ConditionalNG</i> is the same as a <i>Conditional</i>.
      An <i>expression</i> in LogixNG is similar to a
      <i>conditional variable</i> in Logix and an <i>action</i> in
      LogixNG is similar to a <i>conditional action</i> in Logix.</p>

      <p>LogixNG also has references and tables. A reference is an
      indirect pointer to an item on the layout. For example, if
      the memory IM1 has the value "IT1", the reference {IM1} points
      to the turnout IT1. This means that if an action has the
      command "set turnout {IM1} to thrown", it means that LogixNG
      reads the memory IM1, which in this example has the value IT1,
      and then sets the turnout IT1 to thrown.  This is similar to the Logix
      Indirect using <strong>@memoryName</strong>.</p>

      <p>References can be used to change which turnout to use, which
      is very useful to setup generic rules. If a particular rule is
      common for many places on the layout, references can be use to
      use that single rule for all these cases.</p>

      <p>LogixNG also adds tables to JMRI. A table is similar to
      Memory but has one or two dimensions. Each row and each column
      in the table may be given a name, which means that a single
      cell in the table can be referred to with the row name and the
      column name. Tables are in particular intended to be used
      together with references, to make it easy to setup complex
      configurations. A table can be created in a spreadsheet software
      like Microsoft Excel or LibreOffice Calc and then exported as an
      CSV file and imported to JMRI.</p>

      <ul>
        <li><a href="#components">LogixNG Components</a></li>
        <li><a href="#preferences">LogixNG Preferences</a></li>
      </ul>

      <a name="components" id="components"></a>
      <h2>LogixNG Components</h2>

        <p>The LogixNG tool has 3 main components.  They are accessed via the main PanelPro
        <strong>Tools &rArr; Tables &rArr; LogixNG</strong> menu path like other JMRI table items.
        The 3 LogixNG tables and related content will be <strong><em>loaded</em></strong>
        and <strong><em>stored</em></strong> along with all of the other tables and panels.</p>

        <a name="logixngs" id="logixngs"></a>
        <h3>LogixNGs and ConditionalNGs</h3>
          <p>The <strong>LogixNGs</strong> menu item displays a list of LogixNGs.  When a
          LogixNG item is selected, the ConditionalNG list is displayed.  Clicking on the Edit
          button will open the ConditionalNG editor.  This window contains a tree of the
          items that have been added to the conditional.  The primary items are the
          expressions which act like if statements and actions to be performed.  For details,
          see the following pages:</p>
          <ul>
            <li><a href="../../../package/jmri/jmrit/beantable/LogixNGTable.shtml">LogixNG Table</a></li>
            <li><a href="../../../package/jmri/jmrit/logixng/LogixNGTableEditor.shtml">LogixNG Editor</a></li>
            <li><a href="../../../package/jmri/jmrit/logixng/ConditionalNGEditor.shtml">ConditionalNG Editor</a></li>
          </ul>

        <a name="modules" id="modules"></a>
        <h3>Modules</h3>
          <p>The <strong>LogixNG Modules</strong> menu item displays a list of modules.  A
          module is similar to a ConditionalNG in that it also uses the tree based editor.
          The major difference is that information can be passed to a module and it can return
          results.  For details, see the following pages:</p>
          <ul>
            <li><a href="../../../package/jmri/jmrit/beantable/LogixNGModuleTable.shtml">Module Table</a></li>
            <li><a href="../../../package/jmri/jmrit/logixng/ModuleEditor.shtml">Module Editor</a></li>
          </ul>

        <a name="tables" id="tables"></a>
        <h3>Tables</h3>
          <p>The <strong>LogixNG Tables</strong> menu item displays a list of tables.  The
          table feature was described in the introduction. For details, see the following page:</p>
          <ul>
            <li><a href="../../../package/jmri/jmrit/beantable/LogixNGTableTable.shtml">Tables Table</a></li>
          </ul>

        <p><a href="#TopOfPage">[Go to top of page]</a></p>

      <a name="preferences" id="preferences"></a>
      <h2>LogixNG Preferences</h2>
        <p>LogixNG has settings the can be set in JMRI <strong>Preferences &rArr; LogixNG</strong>.</p>

        <div style="margin-left: 2em">
        <a href="images/Preferences.png">
        <img src="images/Preferences.png"
        alt="LogixNG Preferences" width="297" height="198">
        </a>
        </div>

        <dl>
          <dt>Start LogixNGs on load</dt>
          <dd>If checked, the enabled LogixNG definitions will be active after the
          completion of the PanelPro xml data file loading.  If not checked, the LogixNGs
          will be inactive until <strong>Tools &rArr; LogixNG &rArr; Start LogixNG</strong>
          is selected.  The default setting is checked.</dd>

          <dt>Install Debugger</dt>
          <dd>There is an option in the LogixNG editor list for debugging a CondditionalNG.
          This has to be enabled during start up to work.</dd>

          <dt>Show system names and user names</dt>
          <dd>The LogixNG expressions and actions have names.  These names are used
          internally by LogixNG.  In certain developer situations, making the names
          visible can be helpful.  The default is unchecked.</dd>

          <dt>Error Handling Options</dt>
          <dd>LogixNG has robust error handling.  The combo box selection provides the default
          setting.  Individual expressions and actions can override the default setting.</dd>
        </dl>

        <p>Note:  LogixNG execution can be stopped using
        <strong>Tools &rArr; LogixNG &rArr; Stop LogixNG</strong>.</p>

        <p><a href="#TopOfPage">[Go to top of page]</a></p>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h6></h6>
<h6></h6>
<h6></h6>
<p><hr></p>
<hr/>
<hr/>

      <a name="contents" id="contents"></a>
      <h2>Contents</h2>

      <p>The documentation below describes LogixNG, and discusses how
      to set them up. The documentation is divided into sections;
      click below for easy access to a listed section. If you
      prefer to try before reading much, read <a href=
      "#intro">Introduction to LogixNG</a>, then
      click <a href="#start">Getting Started</a> and follow those
      instructions. Return here to read about what you did.</p>

      <ul>
        <li><a href="#intro">Introduction to LogixNG</a></li>

        <li><a href="#system_names">LogixNG system names</a></li>

        <li><a href="#logixng">What are LogixNG</a></li>

        <li><a href="#conditionalng">ConditionalNGs</a></li>

        <li><a href="#editconditionalng">The Edit ConditionalNG
        Window</a></li>

        <li><a href="#logicalexpression">The Logical
        Expression</a></li>

        <li><a href="#thepolicy">Triggering the Actions</a></li>

        <li><a href="#theactions">The Actions</a></li>

        <li><a href="#start">Getting Started</a></li>

        <li><a href="#enable">Enabled and Execution enabled</a></li>

        <li><a href="#notes">Additional Notes</a></li>

        <li><a href="#scripts">Scripts</a></li>

        <li><a href="#actions_expressions">List of actions and expressions</a></li>
      </ul>

      <p>Detail <strong>State Variable</strong> and <strong>Action</strong> Lists:</p>
      <ul>
        <li><a href="../../package/jmri/jmrit/conditional/StateVariableActionList.shtml#variable">State Variables</a> </li>
        <li><a href="../../package/jmri/jmrit/conditional/StateVariableActionList.shtml#action">Actions</a></li>
      </ul>

      <p>ConditionalNG Editor details:</p>
      <ul>
        <li><a href="../../package/jmri/jmrit/conditional/ConditionalNGListEditor.shtml">ConditionalNG List Editor</a> </li>
        <li><a href="../../package/jmri/jmrit/conditional/ConditionalNGTreeEditor.shtml">ConditionalNG Tree Editor</a></li>
      </ul>

      <a name="intro" id="intro"></a>
      <h2>Introduction to LogixNG</h2>

      <p>For those who have used Logix, it's important to note that
      LogixNG is similar, but different.</p>

      <p>The main building blocks in LogixNG are actions and expressions.
      An action does something, for example throwing a turnout, set a signal
      or run a script. An expression asks a question, for example if
      turnout LT2 is closed, or if sensor IS255 is active.</p>

      <p>The actions and expressions are organized in trees, there each
      tree is a ConditionalNG. The ConditionalNGs are organized in LogixNGs.</p>

      <p>An action or expression may have other actions and/or expressions
      as children, which allows the user to build a complex structure
      with simple building blocks.</p>

      <p>Example:<br>
      One common root of the tree is the <strong>IfThenElse</strong> action. It has one
      child expression and one or two child actions. It evaluates the expression and if
      the expression answers <strong>true</strong>, the <strong><em>then</em></strong>
      child action is executed. But if the expression answers <strong>false</strong>,
      the <strong><em>else</em></strong> child action is executed instead.

      <p class="noted">LogixNG is both the name of the JMRI tool and the name of the
      main component of that tool.</p>

<!--
      <a name="components" id="components"></a>
      <h2>LogixNG Components</h2>
      <dl>The three main components of the LogixNG tool are:
        <dt>LogixNG</dt>
        <dt>Module</dt>
        <dt>Table</dt>
      </dl>
 -->


<!--
          <li>
        </ul>

       is the LogixNG table entry, its ConditionalNGs
      and the expresssions and actions defined for the
 -->




	  <a name="system_names" id="system_names"></a>

      <h2>LogixNG system names</h2>

      <p>System names in JMRI consists of a system prefix and a type letter.
	  For LogixNG, the system prefix is usually 'I' and the type letter is 'Q'.
	  But LogixNG consists of several sub types and if all of them would have
	  its own type letter, the letters in the alphabet would run out. Therefore
	  LogixNG has sub type letters, except for LogixNG itself.</p>

	  <p>There is usually no need to work directly with system names and it's
	  recommended to let JMRI to auto generate them. But they can be created
	  manually if desired.</p>

      <p>LogixNG types and example system names</p>
<!-- 	  <table border="1" cellspacing="0"> -->
	  <table>
	    <tr><th>LogixNG type</th><th>System name</th><th>Auto system name</th></tr>
		<tr><td>LogixNG</td><td>IQ0001</td><td>IQ:AUTO:0001</td></tr>
		<tr><td><strong>A</strong>nalog <strong>A</strong>ction</td><td>IQAA0001</td><td>IQAA:AUTO:0001</td></tr>
		<tr><td><strong>A</strong>nalog <strong>E</strong>xpression</td><td>IQAE0001</td><td>IQAE:AUTO:0001</td></tr>
		<tr><td><strong>C</strong>onditionalNG</td><td>IQC0001</td><td>IQC:AUTO:0001</td></tr>
		<tr><td><strong>D</strong>igital <strong>A</strong>ction</td><td>IQDA0001</td><td>IQDA:AUTO:0001</td></tr>
		<tr><td><strong>D</strong>igital <strong>B</strong>oolean action</td><td>IQDB0001</td><td>IQDB:AUTO:0001</td></tr>
		<tr><td><strong>D</strong>igital <strong>E</strong>xpression</td><td>IQDE0001</td><td>IQDE:AUTO:0001</td></tr>
		<tr><td><strong>S</strong>tring <strong>A</strong>ction</td><td>IQSA0001</td><td>IQSA:AUTO:0001</td></tr>
		<tr><td><strong>S</strong>tring <strong>E</strong>xpression</td><td>IQSE0001</td><td>IQSE:AUTO:0001</td></tr>
		<tr><td><strong>T</strong>able</td><td>IQT0001</td><td>IQT:AUTO:0001</td></tr>
	  </table>

	  <p>"Auto system name" refers to system names that are generated automaticly.</p>

	  <p>All system names consists of the system prefix, the type letter, possible a
	  sub type, possible :AUTO: and a number. The number may begin with zeros and the
	  system name IQ1 is different from the system name IQ0001.</p>

	  <p>The LogixNG data types Map and Table are used to make generic LogixNGs. For
	  a table, its columns and rows can also be accessed as NamedBeans.</p>

      <h3>LogixNG table structure</h3>

	  <p>A Table is a data type that holds a two dimensional array, like a spreadsheet.</p>

	  <p>Example:</p>

	  <table>
	  <tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr>
	  <tr><th>&nbsp;1&nbsp;</th><td>IQT22</td><td>Yard table</td><td></td><td></td></tr>
	  <tr><th>&nbsp;2&nbsp;</th><td></td><td>West yard</td><td>East yard</td><td>North yard</td></tr>
	  <tr><th>&nbsp;3&nbsp;</th><td></td><td colspan="3">Left entrance of the yard</td></tr>
	  <tr><th>&nbsp;4&nbsp;</th><td>Leftmost turnout</td><td>IT101</td><td>IT201</td><td>IT301</td></tr>
	  <tr><th>&nbsp;5&nbsp;</th><td>Left turnout</td><td>IT103</td><td>IT203</td><td>IT303</td></tr>
	  <tr><th>&nbsp;6&nbsp;</th><td></td><td colspan="3">Right entrance of the yard</td></tr>
	  <tr><th>&nbsp;7&nbsp;</th><td>Rightmost turnout</td><td>IT112</td><td>IT212</td><td>IT312</td></tr>
	  <tr><th>&nbsp;8&nbsp;</th><td>Right turnout</td><td>IT114</td><td>IT214</td><td>IT314</td></tr>
	  </table>

      <p>LogixNG can use references to access layout items like turnouts in an indirect
	  way. It's done by entering the system name or user name in curly brackets. If
	  a ActionTurnout has the turnout IT1, it will access that turnout directly. But if
	  the ActionTurnout has the turnout {IM2}, it will read that memory and if that
	  memory has a string as a value, it will use that string value to find the turnout.
	  So if the memory IM2 has the value IT5, and the ActionTurnout has the turnout
	  [IM2], the ActionTurnout will read the memory IM2 and find out that it points to
	  the turnout IT5 and therefore do it's action on turnout IT5. The benefit of this
	  is that the Memory can be changed during execution and therefore the same
	  ActionTurnout can be used to access different turnouts at different times.</p>

	  <p>It's possible to use indirect access recursive. If a ActionTurnout has the
	  turnout {IM5}, and that Memory has the value {IM14}, and that the Memory IM14
	  has the value IT3, the ActionTurnout will access IT3. The ActionTurnout has an
	  indirect turnout IM5 so it will read that Memory. And since that memory has the
	  value {IM14} which also is an indirect access, it will read the memory IM14 and
	  find out that it has the value IT3, and therefore use IT3. This is also true for
	  tables. If the cell IQT1[5,3] has the value '{IM3}', and the memory IM3 has the
	  value 'IT5', the cell IQT1[5,3] will point to IT5.</p>

	  <p>A table can be used to create a lookup table. It's accessed by either its
	  system name or its user name, followed by a left square bracket, the name of the
	  column, a comma, the name of the row, and a right square bracket.</p>

	  <p>Instead of the names of the row and column, it's also possible to use the row
	  number or the column number. Note that row 1 has the system name and user name of
	  the table, row 2 has the names of the columns, and column 1 has the names of the
	  rows. Note that for columns, 1 is row A, 2 is row B, 22 is V, 23 is W, 26 is Z,
	  27 is AA and 28 is AB.</p>

	  <p>Note that spreadsheet software, like Excel and LibreOffice Calc, has cell
	  &lt;column letter&gt;&lt;row number&gt; while references in JMRI has table[row,column].
	  Example: Cell B3 is table[3,2], since B3 is row 3 and column 2.</p>

	  <p>Example from the table above. These examples assume that IM3 has the value
	  'West yard', IM4 has the value 'Rightmost turnout' and IM5 has the value 'IQT22'.</p>

	  <table>
	  <tr><td>Cell</td><td>Value</td><td>Note</td></tr>
	  <tr><td>IQT22[1,1]</td><td>IQT22</td><td>Cell A1 has the system name of the table</td></tr>
	  <tr><td>IQT22[1,2]</td><td>Yard table</td><td>Cell B1 has the user name of the table</td></tr>
	  <tr><td>IQT22[2,2]</td><td>West yard</td><td>Cell B2 has the name of column B</td></tr>
	  <tr><td>IQT22[4,1]</td><td>Leftmost turnout</td><td>Cell A4 has the name of row 4</td></tr>
	  <tr><td>Yard table[4,1]</td><td>Leftmost turnout</td><td>The user name of the table can be used to access the table</td></tr>
	  <tr><td>IQT22[5,3]</td><td>IT203</td><td>Cell C5 has the value 'IT203'</td></tr>
	  <tr><td>IQT22[Left turnout,North yard]</td><td>IT303</td><td>Column 'North yard' and row 'Left turnout' has the cell D5 with the value 'IT303'</td></tr>
	  <tr><td>Yard table[Left turnout,North yard]</td><td>IT303</td><td>Column 'North yard' and row 'Left turnout' has the cell D5 with the value 'IT303'</td></tr>
	  <tr><td>IQT22[Leftmost turnout,{IM3}]</td><td>IT101</td><td>IM3 is in curly brackets and have the value 'West yard' so this points to cell B4</td></tr>
	  <tr><td>IQT22[{IM4},East yard]</td><td>IT212</td><td>IM4 is in curly brackets and have the value 'Rightmost turnout' so this points to cell C7</td></tr>
	  <tr><td>IQT22[{IM4},{IM3}]</td><td>IT112</td><td>Column {IM3} and row {IM4} points to cell B7</td></tr>
	  <tr><td>{IM5}[{IM4},{IM3}]</td><td>IT112</td><td>Even the table name can be accessed indirectly</td></tr>
	  </table>

	  <p>Note that a Memory can point to a table. For example, if the memory IM7 has
	  the value '{Yard table[{IM3},Leftmost turnout]}', LogixNG will look at IM7, and
	  find that it's value is in curly brackets. It will then resolve the value inside
	  these curly brackets, which is 'Yard table[{IM3},Leftmost turnout]'. It will then
	  resolve the value of IM3 which has the value 'West yard'. It will then get the
	  table cell 'Yard table[West yard,Leftmost turnout]' which is cell B4 with the
	  value 'IT101'.</p>

	  <p>The ActionForEach iterates over a comma separated list of values. It can be used
	  with tables by using the keywords __columns__ and __rows__ . Note that it's two
	  underscore characters before and after. {IQT1[__columns__]} gives a comma separated
	  list of all the column names in the table IQT1. {IQT1[__rows__]} gives a comma
	  separated list of all the row names in the table IQT1. It's also possible to write
	  {Yard table[__columns__]} and {Yard table[__rows__]}. You can even use this syntax
	  in ActionMemory to assign a Memory the list of column names or row names. Note
	  however that column names or row names that are empty is seen as colums or rows with
	  a comment and therefore they are not included.</p>

	  <p>Tables are loaded by a start up action. They are created in a spreadsheet, like
	  Microsoft Excel or LibreOffice Calc and then exported to a CSV file, separated by
	  TAB characters. The table is read only and is not stored in the panel filee, so it
	  must be reloaded each time JMRI starts.</p>

	  <h3>Note</h3>

      <p>If a name has the characters comma, left or righ square bracket or left or right
	  curly brackets, these characters must be escaped by preceding them with a backslash.
	  Examples: \, \[ \] \{ \} \\</p>

	  <p>If a reference contains a backslash, it will take some more time to evaluate it
	  than if it doesn't contain any backslash. So if it's possible to not use these special
	  characters in references or names of beans, it's recommended.</p>

<!--	  <h3>Important</h3>

	  <p>In order for indirect access to work, some limitations are put on the names
	  used in LogixNG. System names and user names must not contain comma, square brackets
	  and curly brackets. For example, if a turnout has the name 'Green yard, left turnout',
	  it cannot be used with its user name in LogixNG unless the name is changed and the
	  comma is removed.</p> -->




	  <a name="logixng" id="logixng"></a>

      <h2>What are LogixNG?</h2>

      <p>If a LogixNG is enabled and not is being created or edited,
	  a LogixNG is "active", which means that the entities (turnouts,
	  sensors, lights, etc.) in logical expressions of the LogixNG's
      ConditionalNGs are being monitored. Whenever the state of any
      of the monitored entities of a ConditionalNG changes, that
      ConditionalNG "calculates" its logical expression. If the
      result of the calculation changes the value of the logical
      expression, then the specified actions of the ConditionalNG are
      taken.</p>

      <h3>The LogixNG Table</h3>

      <p>A LogixNG is defined via the <a href=
      "../../package/jmri/jmrit/beantable/LogixNGTable.shtml">LogixNG
      Table</a> that can be accessed by selecting <strong>LogixNG
      Table</strong> in the Tools menu. The LogixNG Table lists all
      currently defined LogixNG by their System Name and User Name.
      The table also shows whether a LogixNG is "Enabled". The last
      column of the table provides an easy way to edit a LogixNG and
      its ConditionalNGs. Clicking the <strong>Select</strong> choice box for a
      LogixNG, will drop down a menu with four choices; <strong>Edit</strong>,
      <strong>Browse</strong>, <strong>Copy</strong> and <strong>Delete</strong>.
      Each choice will bring up a pane for the corresponding operation.</p>

      <h4>LogixNG Table controls</h4>

      <ul>
        <li>Below the LogixNG Table is the <strong>Add...</strong> button.</li>

        <li>The Options menu has three sections:
          <ul>
          <li>
          The first section lets you <strong>Enable</strong> or
          <strong>Disable</strong> all LogixNGs.
          </li>
          <li>
          The second section lets you select a user name selection
          method.  See the
          <a href="../../package/jmri/jmrit/beantable/LogixNGTable.shtml#logixOptions">
          LogixNG Options</a> menu for details.
          </li>
          <li>
          The third section lets you select a ConditionalNG Editor.  See the
          <a href="../../package/jmri/jmrit/beantable/LogixNGTable.shtml#logixOptions">
          LogixNG Options</a> menu for details.
          </li>
        </ul></li>

        <li>The Tools menu contains five LogixNG maintenance tools:
          <ul>
            <li>Open picklist tables</li>
            <li>Find orphaned items</li>
            <li>Find empty ConditionalNGs</li>
            <li>Find Cross References</li>
            <li>ConditionalNG Variable References<br>
            <a href="../../package/jmri/jmrit/beantable/images/VariableReferences.png">
            <img src="../../package/jmri/jmrit/beantable/images/VariableReferences.png"
            alt="Variable Reference Window" height="320" width="339">
            </a>
            </li>
          </ul>
        </li>
      </ul>

      <h3>Creating a new LogixNG</h3>

      <p>To create a new LogixNG, click the <strong>Add...</strong> button at
      the bottom of the LogixNG Table pane. This will bring up a
      Create LogixNG window. Entering a System Name and a User Name,
      then clicking <strong>Create LogixNG</strong>, will create the LogixNG, and
      bring up the Edit LogixNG window. This window allows
      ConditionalNGs to be created and edited. Once a LogixNG is
      created, its System Name cannot be changed. Its User Name,
      however, may be changed in either the LogixNG Table or the Edit
      LogixNG window. A new User Name may be any useful text,
      provided the new User Name was not previously assigned to
      another LogixNG.</p>

      <p>A LogixNG is named using the JMRI convention. The System
      Name for the LogixNG always must begin with the two letters IX
      and is usually followed by a number selected by the user. For
      example, valid LogixNG System Names include: IX1, IX34, and
      IX100. The user name is whatever the user wants to use to
      identify the particular LogixNG, for example, "Signal 5
      Control". As a
      convenience to the user, if the entered System Name does not
      begin with IX, the program will add IX in front of what is
      entered. For example, to enter a System Name of IX32, simply
      enter 32 in the System Name field, and the program will do
      the rest.</p>

      <p>The Edit LogixNG window displays the System Name and User
      Name of the LogixNG at the top. The User Name may be changed by
      entering/modifying the text in the User Name field. Next is a
      table of ConditionalNGs belonging to the LogixNG. To add a new
      ConditionalNG, click the <strong>New ConditionalNG</strong> button under
      the ConditionalNG Table. This will create a new ConditionalNG and
      open the Edit ConditionalNG window allowing the logical
      expression and actions of the new ConditionalNG to be defined.
      An existing ConditionalNG may be edited by clicking the
      <strong>Edit</strong> button of that ConditionalNG in the table. The User
      Name of the ConditionalNG may be changed in the table. The User
      Name of a ConditionalNG may be any useful text, provided it is
      not the same as the User Name of another ConditionalNG in the
      same LogixNG. The User Name may be the same as the User Name of
      a ConditionalNG in another LogixNG.  <em>When editing the User Name
      (or any item in any JMRI table) please remember to move to
      another cell in the table so that the program is notified
      that you have finished your entry, otherwise the entry may
      not take effect.</em></p>

      <p>Clicking <strong>Calculate</strong> under the ConditionalNG Table
      causes all ConditionalNGs of the LogixNG to be calculated.
      Resulting states are displayed in the State column of the
      table. However, since the LogixNG is being edited it is
      inactive and therefore no ConditionalNG actions are taken. When
      the editing of the LogixNG is done, the LogixNG is activated and
      may be enabled to allow ConditionalNGs to execute their
      actions.</p>

      <p>The order of ConditionalNGs in the ConditionalNG Table may be
      changed by clicking <strong>Reorder</strong> (below the ConditionalNG
      Table). Clicking <strong>Reorder</strong> changes all edit buttons in
      the last Column of the table to <strong>First</strong>. Select the
      ConditionalNG that is to be first, and it is immediately moved
      to the top of the table. All remaining buttons change to
      <strong>Next</strong>. Select remaining ConditionalNGs in desired order,
      until all buttons change back to <strong>Edit</strong>.</p>

      <p>The only time when the ConditionalNGs are evaluated in the
      order listed is when all of their states are UNKNOWN, such as
      when the LogixNG is being enabled. ConditionalNGs are evaluated
      when one of their expressions changes its state. If an
      entity is used as a expression in more than one
      conditionalNG, it is indeterminate which conditionalNG is
      evaluated first.</p>

      <p>When <strong>Done</strong> is clicked at the bottom of the Edit
      LogixNG window, any change in the LogixNG User Name is checked
      and made. A check is made for inconsistencies in specifying
      that an entity (sensor, turnout, etc.) referenced in multiple
      expressions is not monitored as a trigger for calculation
      of the LogixNG, and a warning message appears if any
      inconsistencies are found. Then the LogixNG is activated, the
      Edit LogixNG window is dismissed, and the user is returned to
      the LogixNG Table. Immediately before the LogixNG is activated,
      the state of all its ConditionalNGs is set to UNKNOWN.
      Immediately after activation, all ConditionalNGs are
      calculated.</p>

      <p>The Edit LogixNG window also provides a way to delete a
      LogixNG if it is no longer needed. Click <strong>Delete LogixNG</strong> to
      delete the LogixNG being edited and all its ConditionalNGs. This
      operation can also be done by selecting the <strong>Delete</strong>
      item from the drop down <strong>Select</strong> menu on the LogixNG
      Table.</p>

      <p>Selecting the <strong>Browse</strong> item from the drop down
      menu on the LogixNG Table will open a window with a list showing
      the details for each conditionalNG. It is an effective way to
      review the entire contents of a LogixNG. Click on the close button
      to close the window.

      <div style="margin-left: 2em">
      <a href="../../package/jmri/jmrit/beantable/images/ConditionalNGBrowser.png">
      <img src="../../package/jmri/jmrit/beantable/images/ConditionalNGBrowser.png"
      alt="ConditionalNG Browser Window" height="296" width="562">
      </a>
      </div>

      <p>Selecting the <strong>Copy</strong> item from the drop down
      <strong>select</strong> menu on the LogixNG Table will show a series of
      dialog windows that provide a way to copy the LogixNG and any
      or all of its ConditionalNG to a new or existing
      LogixNG.</p><a name="conditionalng" id="conditionalng"></a>

      <h2>ConditionalNGs</h2>

      <p>A ConditionalNG's System Name has the form IXnnnnCmm, and is
      set automatically when the ConditionalNG is created by the user
      clicking <strong>New ConditionalNG</strong> in the Edit LogixNG window. The
      System Name of the first ConditionalNG for LogixNG IXnnn will
      always be IXnnnC1, the second ConditionalNG will have System
      Name IXnnnC2, and so on. The User Name of a ConditionalNG is
      whatever the user wants to assign to identify the use of the
      ConditionalNG. An entered User Name must not be used by more
      than one ConditionalNG within a given LogixNG, however. The
      System Name and User Name are displayed at the top of the
      Edit ConditionalNG window. The User Name may be entered/edited
      there or in the ConditionalNG Table of the Edit LogixNG window.
      The User Name of a ConditionalNG may be any useful text,
      provided it is not the same as the User Name of another
      ConditionalNG in the same LogixNG. The user name may be the same
      as the User Name of a ConditionalNG in another LogixNG.</p>

      <p>As mentioned above, ConditionalNGs are statements of the
      form:</p>

      <div style="margin-left: 2em;"><p><code>if (antecedent) then (consequent).
      </code></p></div>

      <p>Therefore a ConditionalNG has two distinct parts: its
      "logical expression" and its "actions". These are discussed
      separately below.</p>

      <p>Logical expressions connect the states (true or false) of
      "expressions". State variables test conditions on the
      layout or in the program, for example, if a sensor is active
      or inactive, if a turnout is closed, if a signal head is red,
      if the fast clock time is between 10:00 and 11:00, etc. State
      variables are linked together in a logical expression by
      logic operators. For a list of currently available expressions, see
      <a href="../../package/jmri/jmrit/beantable/ConditionalNGAddEdit.shtml#variable">State
      Variables</a></p>

      <p>Logic operators currently available are NOT, AND, AND
      NOT, OR and OR NOT. The AND operator is set up automatically
      by the program.
      For each expression, the user selects whether the NOT
      operator is to precede the expression. If the NOT
      operator precedes the expression, the true/false value of
      the expression is reversed. For example, if "Sensor
      Active CS5" is true, "NOT Sensor Active CS5" will be false,
      and vice versa. Note that "Sensor Active CS5" is sometimes
      not the same as "NOT Sensor Inactive CS5", because Sensor CS5
      may be in the UNKNOWN state.</p>

      <p>Logical expressions read like written statements. It is
      easy to set up a logical expression to evaluate many
      situations on the layout. For example, "if block 10 and block
      11 are occupied and turnout 20 is thrown" would be set up
      as:</p>

      <ul>
        <li><code>Sensor "LS1020" is Sensor Active AND Sensor
        "LS1021" is Sensor Active AND Turnout "LT20" is Turnout
        Thrown</code></li>
      </ul>

      <p>where LS1020 is a sensor that is true when block 10 is
      occupied (perhaps from a BDL168), sensor LS1021 is true when
      block 11 is occupied, and Turnout Thrown LT20 is true when
      turnout LT20 is thrown. This logical expression would
      calculate to true if all three of the expressions are
      true, i.e., if block 10 is occupied AND block 11 is occupied
      AND turnout 20 is thrown; otherwise it would calculate
      false.</p>

      <p>Actions may be specified for each ConditionalNG. A number of
      action types are available. For example, Set Turnout, Set
      Signal Appearance, Trigger Route, etc. For a list of currently
      available action types, see <a href="../../package/jmri/jmrit/beantable/ConditionalNGAddEdit.shtml#action">Actions</a>. Each
      action has a user selectable option of being performed if: 1)
      the logical expression changes to true, 2) the logical
      expression changes to false, or 3) the logical expression
      changes. This means a conditionalNG may actually be three
      statements.</p>

      <ul><li>if (antecedent is true) then (do "on change to true"
      actions)</li>

      <li>if (antecedent is false) then (do "on change to false"
      actions)</li>

      <li>if (antecedent state changes) then (do "on change"
      actions)</li>
      </ul>

      <a name="editconditionalng" id="editconditionalng"></a>
      <h3>The Edit ConditionalNG Window</h3>

      <p>The Edit ConditionalNG window is where logical expressions
      are set up and where actions are specified. The Edit
      ConditionalNG window is displayed when a ConditionalNG is
      created, or when the <strong>Edit</strong> button of a ConditionalNG is
      pressed in the Edit LogixNG window. The Edit ConditionalNG window
      displays the System Name and User Name of the ConditionalNG at
      the top. The User Name may be edited by entering/modifying
      the text in the User Name field. Any text may be used,
      provided it doesn't duplicate the user name of another
      ConditionalNG in the same LogixNG. Next are two sections--one for
      the setup of a logical expression and one for set up of the
      actions.</p><a name="logicalexpression" id=
      "logicalexpression"></a>

      <h3>The Logical Expression</h3>

      <p>The logical expression section contains a table of state
      variables, with two buttons and a drop down menu box below.
      The drop down menu allows the choice of what logical
      operators to use in the antecedent. The choices are: all
      <strong>AND</strong>'s, all <strong>OR</strong>'s or
      <strong>Mixed</strong>. Mixed allows the user to specify any combination of
      AND's, OR's and NOT's. When this choice is made the logical expression
      requires parentheses in order to be unambiguous. So, when this choice
      is made, a text field is displayed so that parentheses can be
      inserted and the expression modified. The expressions are
      represented in the expression by their row number.</p>

      <p>The first column in the expression table is the row
      number of the variable. The next column displays the logic
      operation preceding the variable in the expression. In the
      case of "Mixed" a choice box allows the user to choose an
      operation. However these choices can be changed in the
      antecedent text field and it is the text field expression
      that the ConditionalNG uses to determine its state. The third
      column contains a choice box that allows the user to select
      the NOT operator as needed.</p>

      <p>The fourth column is a description of expression and
      the condition to be monitored to be for its state to be true.
      The next column shows the state that was last tested for the
      variable (true or false). The state displayed includes the
      effect of the NOT operator, if NOT is selected.</p>

      <p>The "Trigger" column sets whether the expression
      should cause the ConditionalNG to perform its actions when this
      variable changes. Note that the current states of all the
      variables are <strong>always</strong> used in the calculation of the
      ConditionalNG's state. The "Trigger" setting allows a state
      variable to be "passive" and not cause the conditionalNG to
      evaluate its state. That is, such a variable state is a
      necessary condition, but not a sufficient one to cause any
      actions to take place.</p>

      <p><strong>Note:</strong> Disabling expression triggers should be
      done with caution. Actions are performed only when the state
      of the logical expression changes. Disabling a trigger can
      prevent actions from be executed even when this state has
      changed.</p>

      <p>Next is a column of <strong>Edit</strong> button to modify an
      existing expression. The last column of the table
      (<strong>Delete</strong> buttons) is used to delete a expression if
      you decide it is no longer needed.</p>

      <a name="variable" id="variable"></a>
      <p>Press the <strong>Add State Variable</strong> to add a state
      variable (a row in the State Variable table). This brings up
      a window with a choice box for the user to select a state
      variable type. Available expressions are documented at
      <a href="../../package/jmri/jmrit/beantable/ConditionalNGAddEdit.shtml#variable">State
      Variables</a>. When a type is chosen the Edit
      Variable window displays a text field for the name of the
      entity to be used for the expression. When a name (either
      System Name or user name) is entered, it must correspond to
      an existing entity (sensor, turnout, light, etc.). Depending on
      your <a href="../../package/jmri/jmrit/beantable/LogixNGTable.shtml#selectMethod">selection
      method</a>, a tabbed Pick List,
      a single Pick List or a dropdown combo box will be displayed to
      aid in name selection.</p>

      <p>At any time during the entry of expression data, the
      <strong>Check State Variables</strong> button may be clicked to check
      the entered data and evaluate the expressions. When this
      button is pressed, the checking and evaluation proceeds until
      the check completes successfully, or an error is detected. If
      an error is detected, the checking stops for the user to
      correct the error and click <strong>Check State Variables</strong>
      again. <em>Please remember after editing the System Name and
      data items to click a different cell in the table before
      clicking <strong>Check State Variables</strong> (or <strong>Update
      ConditionalNG</strong> at the bottom of the window) so that the
      program is notified that you have finished your entry.
      Otherwise your entry may not take effect, and an error may be
      reported unnecessarily.</em></p><a name="thepolicy" id=
      "thepolicy"></a>

      <h3>Triggering the Actions</h3>

      <p>There are two policies that can be taken after a
      conditionalNG's state is evaluated:</p>

      <ul>
        <li>Execute the conditionalNG actions only if the state of
        the conditionalNG has changed</li>

        <li>Execute the conditionalNG actions regardless whether the
        state has changed</li>
      </ul>

      <p>Which policy to use is chosen by the radio buttons in the
      middle of the Edit ConditionalNG window. The <strong>Execute actions
      on change of state only</strong> button prevents unwanted behavior
      from occurring when multiple instances of the "on true" or
      "on false" actions are executed. That is, if successive
      triggers cause the logical expression to be evaluated to the
      same state, only the first trigger will execute the actions.
      Normally, it is best for a conditionalNG to execute its actions
      only when the state of the conditionalNG changes. However, if
      it is important to maintain the actions associated with a
      particular state of the ConditionalNG the <strong>Execute actions
      whenever triggered</strong> button should be used. If external
      events undo some of the actions of the conditionalNG but do not
      change the state of the conditionalNG, then this policy will
      execute the action on any trigger.</p><a name="theactions"
      id="theactions"></a>

      <h3>The Actions</h3>

      <p>The Actions section of the Edit ConditionalNG window
      contains a table of actions, with two buttons below for
      adding a new action and reordering the list of actions. The
      section provides for specifying the actions to be taken when
      a ConditionalNG is calculated and changes its state. The action
      table consists of a column for the description of the action
      to be taken and two columns of buttons, <strong>Edit</strong> and
      <strong>Delete</strong>, for editing or deleting an existing action. To
      add a new action, press the "Add Action" button. A new "Edit
      Action" window will appear. Select an action type in the type
      box, and data items needed to completely specify the action
      will appear to the right of the type box. When a name must be
      entered, the name must correspond to the System Name or the
      User Name of an existing entity (sensor, turnout, signal
      head, etc.) of the proper type. Depending on your
      <a href="../../package/jmri/jmrit/beantable/LogixNGTable.shtml#selectMethod">selection method</a>, a tabbed Pick List, a single Pick List or a dropdown
      combo box will be displayed to aid in name selection. Available
      action types are described in detail at
      <a href="../../package/jmri/jmrit/beantable/ConditionalNGAddEdit.shtml#action">Actions</a>.
      <em>If you use User Names to specify your actions, the same caution noted above
      applies. Be very careful when editing User Names that are used to
      specify actions.</em></p>

      <p>For each action, three options are available for when to
      perform the action: 1) On Change to True, 2) On Change to
      False, and 3) On Change. These refer to the calculated state
      of the ConditionalNG, which is equal to the value of the
      logical expression as specified in the expression table.
      One of these options must be selected. When done, click
      either "Update" to install your changes, "Cancel" to close
      the window without any changes or "Delete" to remove the
      action entirely.</p>

      <p>To change the order order of the ConditionalNGs in a LogixNG,
      or the order of the actions in a conditionalNG click the
      "Reorder" button. The right-most buttons in the table will
      then let you select the first one, next one, etc. Note
      however, this is merely the order in which the commands are
      issued but do not guarantee that their final effect will
      occur in the same order. If it is necessary to have actions
      take place in a specified order, use separate ConditionalNGs
      for each action and chain the ConditionalNGs such that a
      preceding action's completed state is the expression for
      the succeeding action.</p><a name="updateconditionalng" id=
      "updateconditionalng"></a>

      <h3>Activating the ConditionalNG</h3>

      <p>When the logical expression and actions have been
      specified, click <strong>Update ConditionalNG</strong> at the bottom of
      the window. This initiates a check of the logical expression
      (the same as done by <strong>Check State Variables</strong>) and a
      check of entered data for actions. If the ConditionalNG's User
      Name has been edited, it is also checked. If an error is
      found, a message box opens announcing the error, and the
      update is stopped to allow the user to correct the error and
      click <strong>Update ConditionalNG</strong> again. If no error is found,
      the ConditionalNG is updated with the entered data, the Edit
      ConditionalNG window is closed, and the user is returned to the
      Edit LogixNG window.</p>

      <p>Two other buttons are available at the bottom of the Edit
      ConditionalNG window. Clicking <strong>Cancel</strong> will close the
      Edit ConditionalNG window without updating the ConditionalNG.
      Clicking <strong>Cancel</strong> results in loss of any data that has
      been entered. The other button, <strong>Delete ConditionalNG</strong>,
      provides an easy way to delete an unneeded ConditionalNG. Click
      <strong>Delete ConditionalNG</strong> to delete the ConditionalNG being
      edited and return to the Edit LogixNG window.</p>



	  <a name="start" id="start"></a>

      <h2>Getting Started</h2>

      <p>The following steps let you create your first LogixNG and
      become familiar with how the LogixNG user interface works.</p>

      <ol>
        <li>Select Table -&gt; <strong><a href=
        "../../package/jmri/jmrit/beantable/LogixNGTable.shtml">LogixNG</a></strong>
        in the <strong>Tools</strong> menu.</li>

        <li>Click the <strong><a href=
        "../../package/jmri/jmrit/beantable/LogixNGAddEdit.shtml">Add...</a></strong>
        button below the LogixNG Table.</li>

        <li>In the Create LogixNG window that appears, enter 6 for
        System Name, and "test" for User Name, then click <strong>Create
        LogixNG</strong>.</li>

        <li>In the Edit LogixNG window that appears, click <strong>New
        ConditionalNG</strong>.</li>

        <li>In the Edit ConditionalNG window that appears, click
        <strong>Add State Variable</strong> to begin defining a logical
        expression for the ConditionalNG.</li>

        <li>In the new window that appears, click the "Variable
        Type" choice box to reveal a scrolling selection box.
        Select "Sensor".</li>

        <li>Note that a text field appears asking for entry of a
        sensor name. Enter the name (either System Name or User
        Name) of any of your existing sensors. (If you don't have
        an existing sensor, select <strong>Sensor Table</strong> in the
        <strong>Tools</strong> menu and create one.)  Select <strong>Inactive</strong>
        from the Variable State drop down.</li>

        <li>Click the <strong>Update</strong> button and note the row entries
        that appear in the expression table.</li>

        <li>Click <strong>New State Variable</strong> to create another row
        in the table. Note that AND appears in the first column of
        the new row. Again select "Sensor" as the variable
        type, and enter the name and desired state of a different
        sensor (create it if needed).</li>

        <li>Click the third column entry of the second row to
        reveal the selection box for NOT. Select NOT, then click
        <strong>Check State Variables</strong> again. Note that the State of
        the second expression has reversed.</li>

        <li>For an Action click <strong>Add Action</strong>.</li>

        <li>In the new window that appears, click the "Action Type"
        choice box to reveal a scrolling selection box. Select
         "Turnout", and enter the name (System Name or User Name) of
        one of your turnouts. (If you don't have any turnouts,
        create one using the <strong>Add</strong> button in the Turnout
        Table.) Select <strong>Set Turnout</strong> for the Action Type,
        leave the "Turnout Position" option at "Closed" and
        "Change Option" at "On Change to True".</li>

        <li>Click the <strong>Update</strong> button and note the row entries
        that appear in the action table.</li>

        <li>For another Action - again click <strong>Add Action</strong> and
        select "Turnout". Enter the name of the same turnout
        entered before. Select "On Change to False" as the Trigger
        Option, and "Thrown" as the Turnout Position.</li>

        <li>Click <strong>Update</strong> to close the Edit ConditionalNG
        window and return to the Edit LogixNG window.</li>

        <li>Click <strong>Done</strong> to close the Edit LogixNG window and
        activate your new LogixNG. Click <strong>OK</strong> in the
        reminder-to-save dialog that appears.</li>
      </ol>

      <p>You'll have created a LogixNG to control the setting of a
      turnout according to the states of two sensors. It's as
      simple as that. It took you more time to read this tutorial
      than to create the LogixNG.</p>

      <h3>Saving LogixNG to disk</h3>

        <p>LogixNG are kept in your <i>layout configuration</i>, along
        with Turnouts, Sensors, Signal Heads, control panel setup etc.
        To store this information on disk, allowing to
        <a href="../../package/jmri/jmrit/display/PanelMenuHelp.shtml">reload
            it</a> next time you run JMRI, use <b>Store Configuration...</b>
        in the <b>File</b> menu at the top of the LogixNG Table (or other
        tables from the Tools menu), or select <b>Store Panel...</b>
        in the <b>Panel</b> menu. Note that the enabled/disabled
        state of each LogixNG is saved in the configuration file.</p>



	  <a name="enable" id="enable"></a>

      <h2>Enabled and Execution enabled</h2>

      <p>The intention with LogixNG is to be similar to Logix, in
	  order to make it easier for users of Logix to understand how
	  LogixNG works.</p>

	  <p>This has resulted in a big challenge when it comes to
	  <strong>Enabled</strong>, since in Logix, a Conditional that
	  is not <strong>Enabled</strong> will still calculate its
	  variables but not execute its actions.</p>

	  <p>In LogixNG, there is a need to be able to completely disable
	  the calculation too, and not only the execution of actions.
	  Therefore, in LogixNG, if a LogixNG or a ConditionalNG is not
	  <strong>enabled</strong>, it's not evaluated at all.</p>

	  <p>But LogixNG also needed to be somewhat compatible with Logix,
	  for example to be able to import Logixs to LogixNG. In order to
	  solve that, LogixNG has <strong>execution enabled</strong>. If
	  a LogixNG or a ConditionalNG doesn't have <strong>execution
	  enabled</strong>, it's only evaluated but not executed.</p>

	  <p>There is however a problem with <strong>execution enabled
	  </strong>. Not all of the actions supports this. Only the actions
	  <a href="#aaa">IfThenElse</a> and <a href="#bbb">Logix</a> supports
	  <strong>execution enabled</strong>.</p>




      <a name="notes" id="notes"></a>
      <h2>Additional Notes</h2>

      <p>This section contains questions and answers that normally
      are not needed by LogixNG users, but in some cases were
      important or of interest for previous versions of LogixNG.</p>

      <ul>
        <li>
          <p><strong>How is a LogixNG started?</strong></p>

          <p>Start of a LogixNG is similar to the way a light, a
          route, or other continuously running JMRI entity starts.
          Internally a LogixNG has an "activate" method, that is
          called when the LogixNG is created, after it is edited, or
          when it is loaded from a configuration file. This method
          starts listeners for items in the expressions of the
          LogixNG's ConditionalNGs. When any of these listeners fires
          (indicating that the watched property of a expression
          has changed), the LogixNG is calculated, resulting in
          appropriate actions being taken, provided the LogixNG is
          enabled.</p>
        </li>

        <li>
          <strong>When should Triggers Calculation be unchecked in an
          expression?</strong>

          <p>Normally Triggers Calculation should be checked in all
          expressions that has this option, so a change in any of its
          expression
          will trigger calculation of a LogixNG. This results in the
          LogixNG quickly reacting to changes on the layout, and
          maintaining the status of signals, turnouts, etc. as
          desired. There are situations, however, where it is
          desirable to test the state of an entity, but not use it
          as a calculation trigger. The following paragraphs
          describe a couple of those situations, but there are
          others.</p>

          <p>Occasionally a "logic loop" can result if triggering
          is not suppressed. For example, if the state of a turnout
          is tested in a expression, and the same turnout is
          set in an action of the same or another ConditionalNG of
          the same LogixNG, continuous triggering (a logic loop)
          could result. The easiest way out of this dilemma is to
          test the turnout, without using it as a triggering
          entity. This is done by unchecking Triggers Calculation
          in <strong>all</strong> expressions where the turnout is
          specified. If the turnout is used in expressions of
          more than one ConditionalNG of the LogixNG, it must be
          unchecked everywhere it is used to suppress using it as a
          trigger.</p>

          <p>Another situation arises when Delayed Set Sensor
          action is used with an internal sensor to trigger a
          second LogixNG after the delay time has elapsed. If the
          second LogixNG is not to be triggered before the delay time
          elapses, all of its expressions, except for the
          delayed internal sensor, should be unchecked. This
          scenario might occur, for example, if a ConditionalNG turns
          on something as its first action, and sets a Delayed Set
          Sensor as its second action to turn off that something
          after a specified time provided certain conditions are
          met.</p>
        </li>

        <li>
          <strong>What is a "logic loop" and how can it be avoided?</strong>

          <p>A "logic loop" results when the program appears to
          slow down significantly or lock up as multiple LogixNGs are
          continuously triggered by changing references to each
          other. The best way to avoid a "logic loop" is to be
          aware of situations that can lead to a loop, and plan
          your logic to avoid such situations.</p>

          <p>A "logic loop" can result within a single LogixNG when a
          expression (sensor, turnout, etc.) that triggers the
          LogixNG is also changed by that same LogixNG. The LogixNG
          editor will detect some situations that could result in a
          loop, and will issue a warning when you close the LogixNG.
          <strong>Heed these warnings!</strong> A warning doesn't mean that a
          loop definitely will result if you continue. The warning
          message is a "wake up call" that you should study
          carefully what you're doing to make sure a loop won't
          result.</p>

          <p>A more complicated situation involving two or more
          LogixNGs can also result in a "logic loop". For example, if
          LogixNG 1 is triggered by sensor A, and has an action that
          changes turnout B, and LogixNG 2 is triggered by turnout B
          and changes sensor A, the potential for a loop exists as
          these LogixNGs trigger each other. You can easily extend
          this idea to triggering chains (loops) involving three or
          more LogixNGs, and even to interactions between LogixNGs and
          Routes. There is no test in the program to warn about
          loops involving multiple LogixNGs. (To develop such a test
          would be very difficult.)</p>
        </li>

        <li>
          <strong>What should I do if I think I have a "logic loop"?</strong>

          <p>When they do occur, "logic loops" can be a bit scary
          to trouble shoot. Your computer may appear to be locked
          up, or slowed to a crawl as the loop uses up most of the
          available computer time. Fortunately JMRI provides tools
          to help in design and debugging. Unchecking "Triggers
          Calculation" for a expression (discussed above), can
          help you design around loops when you have identified the
          LogixNG causing the looping problem. To get around the lock
          up or slow down problem, start with all your LogixNGs
          disabled, (see below) then enable them one by one until
          you discover the loop.</p>

          <p>If the panel file containing LogixNGs loads
          automatically when the program starts up, press and
          release the shift key a few times rapidly as soon as you
          see the small JMRI splash screen (the first thing you see
          during start up). Your panel file will be loaded with all
          LogixNGs disabled.</p>

          <p>If you load your panel file manually using the Panels
          &gt; Open Panel...
          menu, before loading your file, go to the <strong>Debug</strong>
          menu and select <strong>Load LogixNGs Disabled</strong>. After
          responding OK to the message, load your panel file as you
          normally would. Your panel file will be loaded with all
          LogixNGs disabled.</p>

          <p>After loading your panel file, open the LogixNG Table
          and verify that all LogixNGs are disabled. If you know
          which LogixNG is causing the trouble, you can then fix it
          or delete it, re-enable the other LogixNGs, and save your
          panel file. If you don't know which LogixNG is causing the
          problem, you can enable your LogixNGs, one by one, until
          the loop occurs. When the loop starts, you know that the
          last LogixNG you enabled is at least partly responsible for
          the problem. At this point you should restart the program
          with all LogixNGs disabled, and fix or delete the LogixNG you
          identified.</p>

          <p><strong>CAUTION:</strong> <strong>It's wise to save your panel file
          frequently when entering LogixNGs.</strong> If a logic loop
          occurs, it may be difficult, if not impossible, to save
          your panel file before shutting down the program.
          Remember that a LogixNG is activated as soon as you click
          <strong>Done</strong> in the Edit LogixNG window. Also, remember that
          hitting an <strong>Edit</strong> button in the LogixNG Table
          deactivates the selected LogixNG before opening it for
          editing, offering a possible way to break into a logic
          loop without restarting the program.</p>
        </li>
      </ul>



	  <a name="scripts" id="scripts"></a>

      <h2>Scripts</h2>

      <p>All types of LogixNG actions and expressions may use
	  Python/Jython scripts. Below follows the description of
	  scripts for digital expressions, but the same pattern
	  applies to all the types of actions and expressions.</p>

      <p>The digital expression that handles scripts is
	  ExpressionScript.</p>

      <p>The script that is executed by ExpressionScript must
	  declare a class that extend the class AbstractScriptDigitalExpression.
	  The script must override the method evaluate(). For a
	  script that listen to other beans, it's recommended to
	  also override the methods registerScriptListeners() and
	  unregisterScriptListeners().</p>

	  <p>When called, the script must tell the caller which
	  class to use. It does that by setting the variable
	  params._scriptClass.set(instance)</p>

      <p>Example of a digital expression script:</p>

      <div style="margin-left: 2em;"><p><code>
      import jmri<br>
      <br>
      class MyExpression(jmri.jmrit.logixng.digital.expressions.AbstractScriptDigitalExpression):<br>
      <br>
      &nbsp;&nbsp;l = lights.provideLight(\"IL1\")<br>
      <br>
      &nbsp;&nbsp;def registerScriptListeners(self):<br>
      &nbsp;&nbsp;&nbsp;&nbsp;self.l.addPropertyChangeListener(\"KnownState\", self);<br>
      <br>
      &nbsp;&nbsp;def unregisterScriptListeners():<br>
      &nbsp;&nbsp;&nbsp;&nbsp;l.removePropertyChangeListener(\"KnownState\", this);<br>
      <br>
      &nbsp;&nbsp;def evaluate(self):<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return self.l.commandedState == ON<br>
      <br>
      params._scriptClass.set(MyExpression(params._parentExpression))<br>
      </code></p></div>



	  <a name="indirect_accessing" id="indirect_accessing"></a>

      <h2>Indirect adressing of NamedBeans</h2>

      <p>In some cases, it may be useful to use indirect addressing of NamedBeans.</p>

      <p>This can be done in two ways:</p>
      <ul>
	      <li>Using a Memory that has the name of the NamedBean</li>
          <li>Using a NamedBeanMap to lookup the name of the NamedBean</li>
      </ul>

      <p>Using a Memory that has the name of the NamedBean</p>

      <p>Lets say we have an ActionTurnout that should throw a particulat turnout.
      But we wnat to be able to select which turnout to throw at a later time.
      We can solve that by storing the system name or user name in a Memory.
      We then tell the ActionTurnout to read the Memory and lookup the turnout
      on the fly.</p>

      <p>Since LogixNG fully supports string manipulation and calculations of both
      integers and floating point values, where are plenty of possibilities here.</p>

      <h3>Warning</h3>

      <p>There is one major drawback with this. Since LogixNG doesn't know in
      advance which NamedBeans will be accessed indirectly, it's not possible
      for LogixNG to automaticly register listeners to the named beans that
      should trigger on change. For example, an ExpressionTurnout registers
      a listener on the turnout, if the name of the turnout is given, but if
      the ExpressionTurnout is using indirect addressing of the turnout, it's
      not able to do that.</p>

      <p>The solution is to use the ActionListenOnBeans and tell this action
      which beans to listen on. Any time any property of any of the named
      beans this action listen to, the ConditionalNG will be executed.</p>

      <p>Example:</p>
      <p>A ConditionalNG is using turnouts IT1, IT2, IT3, IT4 and IT5 in it's
      expressions and wants each of them to trigger on change. Turnouts
      IT1 and IT3 and IT4 are directly accessed in expressions and IT2, IT3
      and IT5 is indirect accessed.</p>

      <p>Each turnout that is directly addressed in an expression will the
      ConditionalNG listen to automaticly, so IT1, IT3 and IT4 will be listen
      to. But in order to listen on turnouts IT2 and IT5, the
      ActionListenOnBeans needs to be used.</p>

      <p>The ActionListenOnBeans can be placed anythere in the ConditionalNG
      tree, as long as it and its parents are enabled. If you disable this
      action, or any of its parent actions, the ActionListenOnBeans will not
      listen on its named beans.</p>

	  <h3>Special actions</h3>

	  <p>There are a couple of actions that is particular useful for this.</p>

	  <p><strong>ActionFor</strong></p>

	  <p>ActionFor is a for-loop. It has four children.</p>
	  <ul>
	      <li><strong>Init</strong> - this action is first executed once. It's
          used to initialize the loop, for example setting a Memory to a particular
          value.</li>

          <li><strong>Condition</strong> - this expression decides if the loop
          should run one lap more. The loop will continue to run until this
          condition will be <strong>false</strong>.</li>

          <li><strong>Next</strong> - this action is executed at the end of the
          loop. It can for example be used to increment a counter in a Memory.</li>

          <li><strong>Action</strong> - this action is executed in each loop. It
          does the main work.</li>
      </ul>

	  <p>Then ActionFor is executed, the Init action is run once. After that, the
	  Condition expression is evaluated. If the condition returns <strong>true</strong>,
	  the Action action is executed and at last the Next action is executed. Then
	  the process is repeated, except that the Init action is only executed once.</p>

	  <p><strong>ActionForEach</strong></p>

	  <p>ActionForEach is a for-loop.</p>

	  <p>This action has a list of items. Either a constant list, or it can use a
	  NamedBeanMap.</p>

	  <p>The ActionForEach action loops thru the list. It takes the first item in
	  the list, assigns it to a Memory, and then executes its child action. Then it
	  takes the second item in the list, assigns it to the Memory, and executes the
	  child action.</p>




      <a name="digital_actions" id="digital_actions"></a>
      <h2>List of digital actions</h2>

      <p>This section lists all the digital actions that is currently
	  available with LogixNG.</p>

      <p>Digital actions do something. Example: Set sensor IS2 to ON.
      Throw turnout LT52.</p>

      <p>Digital actions have system names with the letters
      <strong>DA</strong> (for <strong>D</strong>igital
      <strong>A</strong>ction). Example: IQDA002 or IQDA:0053.
      System names with colon are auto generated system names.</p>

      <p style="color:red">Items in red may need rethink or removal. I have ideas, but not always
	  sure if these ideas are worth keeping. /Daniel</p>

      <p style="color:blue">Items in blue is not up to date with documentation.
	  The documentation tells how they should work, but the code is not finished yet.
	  /Daniel</p>

      <ul>
        <li>
          <p><strong>Light</strong></p>

          <p>The Light action sets a light.</p>
        </li>

        <li>
          <p><strong>Sensor</strong></p>

          <p>The Sensor action sets a sensor.</p>
        </li>

        <li>
          <p><strong>Turnout</strong></p>

          <p>The Turnout action sets a turnout.</p>
        </li>

        <li>
          <p><strong>Throttle</strong></p>

          <p>The Throttle action controls a throttle. It has child expressions
          for loco address, loco speed and loco direction. For now, an analog
          memory expression or an analog constant expression can be used to
          control the loco address and the loco speed, but once JMRI has
          support for AnalogIO devices, an AnalogIO may be used to control
          loco address and/or loco speed.</p>
        </li>

        <li>
          <p><strong>Timer</strong></p>

          <p>The Timer action executes a child action after some time.</p>
        </li>

        <li>
          <p><strong>DoAnalogAction</strong></p>

          <p>The DoAnalogAction reads an analog child expression and executes
          an analog child action.</p>
        </li>

        <li>
          <p><strong>DoStringAction</strong></p>

          <p>The DoStringAction reads an string child expression and executes
          an string child action.</p>
        </li>

        <li>
          <p><strong style="color:red">HoldAnything</strong></p>

          <p style="color:red">Remove this</p>

          <p>The HoldAnything can hold any type of action or expression.</p>
        </li>

        <li>
          <p><strong>IfThenElse</strong></p>

          <p>The IfThenElse reads a digital child expression and if the
          answer is <strong>true</strong> it executes the <strong>then</strong>
          child action, else it executes the <strong>else</strong> child action.
        </li>

        <li>
          <p><strong>Logix</strong></p>

          <p>The Logix action reads a digital child expression and then executes
          boolean actions. Each boolean action takes the result from the
          expression and takes action accordingly. The recommended child boolean
          actions for this action is the OnChange action. The Logix action, together
          with the OnChange child boolean actions, acts like the JMRI Logix, with
          explains the name of this action.</p>
        </li>

        <li>
          <p><strong>Many</strong></p>

          <p>The Many action executes many child actions.</p>
        </li>

        <li>
          <p><strong>ShutdownComputer</strong></p>

          <p>The ShutdownComputer action either shutdown or restarts the computer.
          This action is mainly included to demonstrate the possibilities of LogixNG,
          but it may be useful in some cases, for example when a Raspberry Pi computer
          runs the layout and there is no keyboard and mouse connected to the Raspberry
          Pi computer. It's then possible to use a sensor to shutdown the computer.</p>
        </li>

      </ul>


      <a name="digital_boolean_actions" id="digital_boolean_actions"></a>
      <h2>List of digital boolean actions</h2>

      <p>This section lists all the digital boolean actions that is currently
	  available with LogixNG.</p>

      <p>Digital boolean actions takes a true/false value and do something.
	  The most common use is the digital action Logix together with the digital
	  boolean action OnChange.</p>

      <p>Digital boolean actions have system names with the letters
      <strong>DB</strong> (for <strong>D</strong>igital
      <strong>B</strong>oolean action). Example: IQDB002 or IQDB:0053.
      System names with colon are auto generated system names.</p>

      <p style="color:red">Items in red may need rethink or removal. I have ideas, but not always
	  sure if these ideas are worth keeping. /Daniel</p>

      <p style="color:blue">Items in blue is not up to date with documentation.
	  The documentation tells how they should work, but the code is not finished yet.
	  /Daniel</p>

      <ul>
        <li>
          <p><strong>OnChange</strong></p>

          <p>Executes a child action if the parameter is changed and to the
          desired value.</p>
        </li>

      </ul>


      <a name="digital_expressions" id="digital_expressions"></a>
      <h2>List of digital expressions</h2>

      <p>This section lists all the digital expressions that is currently
	  available with LogixNG.</p>

      <p>Digital expressions asks a question and gives a true/false
      answer. Example: Is sensor IS2 on? Is turnout LT52 thrown?</p>

      <p>Digital expressions have system names with the letters
      <strong>DE</strong> (for <strong>D</strong>igital
      <strong>E</strong>xpression). Example: IQDE002 or IQDE:0053.
      System names with colon are auto generated system names.</p>

      <p style="color:red">Items in red may need rethink or removal. I have ideas, but not always
	  sure if these ideas are worth keeping. /Daniel</p>

      <p style="color:blue">Items in blue is not up to date with documentation.
	  The documentation tells how they should work, but the code is not finished yet.
	  /Daniel</p>

      <ul>
        <li>
          <p><strong>And</strong></p>

          <p>The And expression has a number of child expressions and
          answers <strong>true</strong> if and only if all of the child
          expressions answers <strong>true</strong>. If any of the child
          expressions answer <strong>false</strong>, the
          <strong>And</strong> expression answers <strong>false</strong>.
        </li>

        <li>
          <p><strong>Antecedent</strong></p>

          <p>The Antecedent expression has a formula together with a
          number of child expressions. It evaluates the formula with the
          results from the child expressions. The Antecedent expression
          follows the same rules as in a Conditional in Logix. A
          Antecedent formula can have parentheses and the words
          <strong>AND</strong> and <strong>OR</strong> to build the
          formula.
        </li>

        <li>
          <p><strong>Light</strong></p>

          <p>The Light expression checks the state of a light and answers
          <strong>true</strong> if the light has the desired state.
        </li>

        <li>
          <p><strong>Sensor</strong></p>

          <p>The Sensor expression checks the state of a sensor and answers
          <strong>true</strong> if the sensor has the desired state.
        </li>

        <li>
          <p><strong>Turnout</strong></p>

          <p>The Turnout expression checks the state of a turnout and answers
          <strong>true</strong> if the turnout has the desired state.
        </li>

        <li>
          <p><strong>False</strong></p>

          <p>The False expression always answers <strong>false</strong>.
        </li>

        <li>
          <p><strong>True</strong></p>

          <p>The True expression always answers <strong>true</strong>.
        </li>

        <li>
          <p><strong style="color:red">Hold</strong></p>

          <p>The Hold expression has two child expressions, one trigger
          expression and one hold expression. For this expression to
          become <strong>true</strong>, both the trigger expression and the
          hold expression must answer <strong>true</strong>. But then it
          stays <strong>true</strong> as long as the hold expression stays
          <strong>true</strong>.
        </li>

        <li>
          <p><strong>Or</strong></p>

          <p>The Or expression has a number of child expressions and
          answers <strong>true</strong> at least one the child
          expressions answers <strong>true</strong>. If all of the child
          expressions answer <strong>false</strong>, the
          <strong>And</strong> expression answers <strong>false</strong>.
        </li>

        <li>
          <p><strong>Not</strong></p>

          <p><strong style="color:red">This expression does not exist yet.
          Implement it.</strong></p>

          <p>The Not expression has one child expression and
          answers <strong>true</strong> if the child
          expression answer <strong>false</strong>, and <strong>false</strong>
          if the child expression answers <strong>true</strong>.
        </li>

        <li>
          <p><strong style="color:blue">ResetOnTrue</strong></p>

          <p><strong style="color:red">Update the code</strong></p>

          <p>The ResetOnTrue expression has two child expressions, one
          primary expression and one secondary expression. When the primary
          expression becomes <strong>true</strong>, the secondary expression
          is reset. This expression is primary designed to be used with a timer
          expression as the secondary expression. The timer will then restart
          when it's reset.</p>

          <p>The user can select between four different ways on when this
          expression answers <strong>true</strong>.</p>

          <ul>
            <li>The primary expression trigger, and until the secondary expression becomes true.</li>
            <li>The primary expression trigger, and while the secondary expression is true.</li>
            <li>The primary expression stays true, and until the secondary expression becomes true.</li>
            <li>The primary expression stays true, and while the secondary expression is true.</li>
          </ul>

          <p>Example usages for this expression:</p>

          <ul>
            <li>Wait on a timer. For example, when turnout IT1 is thrown, wait 5 seconds until expression becomes true.</li>
            <li>Wait on a timer. For example, when turnout IT1 is thrown, let the expression be true for 5 seconds.</li>
          </ul>
        </li>

        <li>
          <p><strong>Timer</strong></p>

          <p>The Timer expression waits some time then it's reset.
        </li>

        <li>
          <p><strong>TriggerOnce</strong></p>

          <p>The TriggerOnce expression answers <strong>true</strong> one single
          time and then <strong>false</strong> until JMRI is restarted. It's
          designed to be used when something needs to be done exactly one time,
          for example set some turnouts to a specified inital state or to set
          some memories to some predefined values.
        </li>
      </ul>

      <!--#include virtual="/Footer.shtml" -->
    </div><!-- closes #mainContent-->

  </div><!-- closes #mBody-->
  <script src="/js/main.js"></script>
</body>
</html>
