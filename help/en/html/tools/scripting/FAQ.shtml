<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<!-- Copyright Bob Jacobsen 2008 -->
<!-- $Id: FAQ.shtml,v 1.3 2008-03-09 19:57:54 jacobsen Exp $ -->
<title>JMRI: Scripting FAQ</title>

<!-- Style -->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="/css/default.css" media="screen">
<link rel="stylesheet" type="text/css" href="/css/print.css" media="print">
<link rel="icon" href="/images/jmri.ico" TYPE="image/png">
<link rel="home" title="Home" href="/">
<!-- /Style -->
</head>

<body>
<!--#include virtual="/Header" -->

<!--#include virtual="Sidebar" -->
<div id="mainContent">

      <!-- Page Body -->
        <H2>
		JMRI: Scripting FAQ
        </H2>

		<p class=subtitle>
		    Frequently asked questions about scripting JMRI
		    with Jython
		</p>


		<div class=section>
		    <h2>Where can I learn more about the Jython language?</h2>

		    <div class=para>
		    
		    <p>See the
		    <A HREF="Python.shtml">Python &amp; JMRI</a>
		    page for more info, including pointers to articles, etc.
		    See also the navigation links to the left.
            </div>
            
		</div>

		<div class=section>
		    <h2>How do Jython and Python differ?</h2>

		    <div class=para>
		    
		    <p>For the purposes of writing JMRI scripts, they
		    don't differ very much.  Most of the differences involve
		    what happens in somewhat contrived error cases.
		    There are also some restrictions
		    on what you can do with the computer's configuration
		    information, etc, in Jython, but these are not things
		    a JMRI script is likely to need.</p>
		    <P>Some additional information on the differences
		    is 
		    <A HREF="http://jython.sourceforge.net/docs/differences.html">available here</a>.
		    </div>

		</div>

		<div class=section>
		    <h2>Where can I find some examples of JMRI scripts?</h2>

		    <div class=para>
		    
		    See the 
		    <a href="Examples.html">examples page</a>.
		    Also, the
		    <a href="Start.html">introductory page</a>
		    shows some of the basic commands.
		    </div>

		</div>

		<div class=section>
		    <h2>What do those words like 
		    "<code>import</code>",
		    "<code>class</code>", etc, in the example files mean?
		    </h2>

		    <div class=para>
            They're part of the jython language used for the scripting.
            <P>
            The imports allow you to refer to things by shorter names, 
            essentially telling jython "search the jarray, jmri packages and 
            recognize all the names there".   For somebody trying to understand 
            this script, you can just treat them as "ensuring the program can 
            find parts we want".
            <P>
            "class" means "start the definition of a group of things that go 
            together"  (all you other experts, please don't jump on me about 
            this; I understand both intrinsic/extrinsic polymorphism, I'm just 
            trying to get the general idea across).  
            <P>
            For example, in the SigletExample.py file is a description of a 
            "class" called SigletExample, which contains two 
            routines/functions/members:  A subroutine called "defineIO", and one 
            called "setOutput"
            <P>
            This "class" is associated with another called "Siglet" (actually 
            jmri.jmrit.automat.Siglet; that's that long naming thing again), 
            which knows when to invoke routines by those two names to get done 
            what you want.
            <P>
            Essentially, you're defining two parts ("defineIO" & "setOutput") 
            that plug into a pre-existing structure to drive signals.  That 
            pre-existing structure is very powerful, and lets you do all sorts of 
            things, but also provides this method to try to keep it simpler.
            <P>
            OK, at this point most people's eyes are fully glazed over.  Your 
            best bet when starting with this stuff is to use the "copy and 
            modify" approach to software development.  It's good to try to 
            understand the entire content of the file, but don't worry about 
            understanding it well enough to be able to recreate it from scratch. 
            Instead, just modify little bits and play with it.
		    </div>

		</div>

		<div class=section>
		    <h2>Are there required naming conventions?</h2>

		    <div class=para>
            In many of the sample files, turnouts are referred to by 
            names like "to12", signals by names like "si21",
            and sensors by names like "bo45". These conventions grew out of 
            how some older code was
            written, and they can make the code clearer.  
            But they are in no way required; the
            program doesn't care what you call variables.
            <P>
            For example, "self.to12" is just the name of a variable.  
            You can call it anything 
            you want, e.g. self.MyBigFatNameForTheLeftTurnout
            <P>
            The "self" part makes it completely local; "self" refers to "an 
            object of the particular class I'm defining right now".  Alternately, 
            you can define a global variable, but that's not recommended.  If you 
            have multiple scripts running (and you can have as many as you'd 
            like; we recommend that you put each signal head in a separate one), 
            the variables can get confused if you use the same variable name to 
            mean too different things.  Using "self" like this one does makes 
            sure that doesn't happen.
            <P>
            Note that turnouts, etc, do have "System Names" that look like 
            "LT12".  You'll see those occasionally, but that's something 
            different from the variable names in a script file.		   
            </div>

		</div>
		<a name="windows">
		<div class=section></a>
		    <h2>Can a script access the JMRI application windows?</h2>

		    <div class=para>
            Your scripts can change the properties of all the main 
            JMRI windows. They're all jmri.util.JmriJFrame objects,
            so they have all the various methods of a Swing JFrame.
            For example, this code snippet
            <p>
            <code>
            window = jmri.util.JmriJFrame.getFrameList()[1]<br/>
            window.setLocation(java.awt.Point(0,0))
            </code>
            <p>
            locates the application's main window, and sets its 
            location to the upper left corner of the screen.
            <p>
            The <code>jmri.util.JmriJFrame.getFrameList()</code>
            call in the first line returns a list of the existing 
            windows. The [0] element of this list is the original
            splash screen and the [1] element is the main window;
            after that, they're the various windows in the order they
            are created.  To find a particular one, you can
            index through the list checking e.g. the window's title
            with the <code>getTitle()</code> method.
            
            </div>

		</div>
		<div class=section>
		    <h2>What's the difference between the "Siglet" and "AbstractAutomaton" classes?</h2>

		    <div class=para>
            (Maybe not a <em>frequently</em> asked question, but it needs
            to go somewhere)
            <P>
            Some examples use the 
            <A HREF="http://jmri.sourceforge.net/JavaDoc/doc/jmri/jmrit/automat/AbstractAutomaton.html">AbstractAutomaton</a>
            class as a base, while
            others use the 
            <A HREF="http://jmri.sourceforge.net/JavaDoc/doc/jmri/jmrit/automat/Siglet.html">Siglet</a>
            class. This is because those are intended for two different 
            purposes.
            <P>
            "Siglet" is meant to be used for driving signals.  You
            provide two pieces of code:
            </dl>
            <dt>defineIO<DD>which defines the various sensors, turnouts
            and signals that the output signal depends on as input when
            calculating the appearance of the signal.
            <dt>setOutout<dd>which recalculates the signal appearance
            from the defined inputs.
            </dl>
            <P>The Siglet base class then handles all of the listening
            for changes, setting up for parallel execution, etc. Your
            defineIO routine will be called once at the beginning, and 
            after than any time one or more of the inputs changes, your setOutput
            routine will be called to recalculate the signal appearance.
            <P>
            Of course, you can use this class to calculate other things than
            signal appearances.  But the key element is that the calculation
            is redone when the inputs change, and only when the inputs change.
            <P>
            AbstractAutomaton is a more general class that's intended
            to allow more powerful operations (and Siglet actually
            uses that more powerful base).  You define two functions:
            <DL>
            <DT>init<DD>which is called exactly once to do any one-time
            setup you need
            <DT>handle<DD>which is called over and over and over again
            until it returns FALSE.
            </DL>
            
            Using AbstractAutomoton provides you with a number of 
            tools:  you can wait for a particular sensor to go
            active, do something, then wait for a different sensor
            to go inactive, etc.  This allows you much more freedom to
            create complicated &amp; powerful sequences than the Siglet class,
            because Siglets are limited to doing just one thing (they aren't
            intended to do sequences of operations).
            <P>
            For more info on the routines that AbstractAutomaton provides
            to help you, see the 
            <A HREF="http://jmri.sourceforge.net/JavaDoc/doc/jmri/jmrit/automat/AbstractAutomaton.html#method_summary">JavaDocs</a>
            for the class. (Scroll down to the section called "Method Summary")
            </div>

		</div>

		<div class=section>
		    <h2>How can I limit the priority of a script?</h2>

		    <div class=para>
            <P>If the script runs a loop that's supposed to update something, it 
            can't be written to run continuously or else it will just suck up as 
            much computer time as it can.  Rather, it should wait.

            <P>The best thing to do is to wait for something to change.  For 
            example, if your script looks at some sensors to decide what to do, 
            wait for one of those sensors to change (see the sample scripts for 
            examples)

            <P>Simpler, but not as efficient, is to just wait for a little while 
            before checking again. For example
<PRE>
    waitMsec(1000)
</PRE>
            causes an automaton or Siglet script to wait for 
            1000 milliseconds (one second) before continuing.
            <P>
            For just a simple script, something that doesn't use the
            Automat or Siglet classes, you can sleep by doing
            
<PRE>
from time import sleep
sleep(10)
</PRE>
            The first line defines the "sleep" routine, and only needs
            to be done once.  The second line then sleeps for 10 seconds.
            Note that the accuracy of this method is not as good as
            using one of the special classes.
		    </div>

		</div>

<!--#include virtual="/Footer" -->
</body>
</html>
