<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Apple macOS version 5.8.0">
  <title>JMRI: LogixNG Documentation</title>
  <meta name="author" content="David Duchamp">
  <meta name="author" content="Daniel Bergqvist">
  <meta name="author" content="Dave Sand">
  <meta name="keywords" content="java model railroad JMRI LogixNG">
  <!--#include virtual="/Style.shtml" -->
</head>
<body>
  <!--#include virtual="/Header.shtml" -->

  <div id="mBody">
    <!--#include virtual="Sidebar.shtml" -->

    <div id="mainContent">
      <h1><a id="TopOfPage"></a>JMRI: LogixNG Documentation</h1>

      <p class="noted">LogixNG, along with its documentation, is still evolving. Some text
      is based on the original Logix documents.</p>

      <p>JMRI has for a long time had the tool Logix which can be used to create rules, for example
      that a signal should go to green if some turnouts are in a predefined state. Logix does its
      job well, but is difficult to extend with new functionality.</p>

      <p>LogixNG, short for Logix Next Generation, is a complete rethink of the concept. It's
      modular, which means it's easy to extend LogixNG with new functionality, and it's easy to test
      each part of LogixNG.</p>

      <p>LogixNG have building blocks that are similar to Logix. A <em>LogixNG</em> is the same as
      a <em>Logix</em>. A <em>ConditionalNG</em> is the same as a <em>Conditional</em>. An
      <em>expression</em> in LogixNG is similar to a <em>conditional variable</em> in Logix and an
      <em>action</em> in LogixNG is similar to a <em>conditional action</em> in Logix.</p>

      <p>LogixNG also has references and tables. A reference is an indirect pointer to an item on
      the layout. For example, if the memory IM1 has the value "IT1", the reference {IM1} points to
      the turnout IT1. This means that if an action has the command "set turnout {IM1} to thrown",
      it means that LogixNG reads the memory IM1, which in this example has the value IT1, and then
      sets the turnout IT1 to Thrown. This is similar to the Logix Indirect using
      <strong>@memoryName</strong>.</p>

      <p>References can be used to change which turnout to use, which is very useful to set up
      generic rules. If a particular rule is common for many places on the layout, references can
      be use to use that single rule for all these cases.</p>

      <p>LogixNG also adds tables to JMRI. A table is similar to Memory but has one or two
      dimensions. Each row and each column in the table may be given a name, which means that a
      single cell in the table can be referred to with the row name and the column name. Tables are
      in particular intended to be used together with references, to make it easy to set up complex
      configurations. A table can be created in a spreadsheet software like Microsoft Excel or
      LibreOffice Calc and then exported as an CSV file and imported into JMRI.</p>

      <ul>
        <li>
          <a href="#components">LogixNG Components</a>
        </li>

        <li>
          <a href="#preferences">LogixNG Preferences</a>
        </li>
      </ul>
      <a id="components"></a>
      <h2>LogixNG Components</h2>

      <p>The LogixNG tool has three main components. They are accessed via the main PanelPro
      <strong>Tools &rArr; Tables &rArr; LogixNG</strong> menu path like other JMRI table items. The 3
      LogixNG tables and related content will be <strong><em>loaded</em></strong> and
      <strong><em>stored</em></strong> along with all of the other tables and panels.</p>
      <a id="logixngs"></a>
      <h3>LogixNGs and ConditionalNGs</h3>

      <p>The <strong>LogixNGs</strong> menu item displays a list of LogixNGs. When a LogixNG item
      is selected, the ConditionalNG list is displayed. Clicking on the Edit button will open the
      ConditionalNG editor. This window contains a tree of the items that have been added to the
      conditional. The primary items are the expressions which act like if statements and actions
      to be performed. For details, see the following pages:</p>

      <ul>
        <li>
          <a href="../../../package/jmri/jmrit/beantable/LogixNGTable.shtml">LogixNG Table</a>
        </li>

        <li>
          <a href="../../../package/jmri/jmrit/logixng/LogixNGTableEditor.shtml">LogixNG Editor</a>
        </li>

        <li>
          <a href="../../../package/jmri/jmrit/logixng/ConditionalNGEditor.shtml">ConditionalNG
          Editor</a>
        </li>
      </ul>
      <a id="modules"></a>
      <h3>Modules</h3>

      <p>The <strong>LogixNG Modules</strong> menu item displays a list of modules. A module is
      similar to a ConditionalNG in that it also uses the tree based editor. The major difference
      is that information can be passed to a module and it can return results. For details, see the
      following pages:</p>

      <ul>
        <li>
          <a href="../../../package/jmri/jmrit/beantable/LogixNGModuleTable.shtml">Module Table</a>
        </li>

        <li>
          <a href="../../../package/jmri/jmrit/logixng/ModuleEditor.shtml">Module Editor</a>
        </li>
      </ul>
      <a id="tables"></a>
      <h3>Tables</h3>

      <p>The <strong>LogixNG Tables</strong> menu item displays a list of tables. The table feature
      was described in the introduction. For details, see the following page:</p>

      <ul>
        <li>
          <a href="../../../package/jmri/jmrit/beantable/LogixNGTableTable.shtml">Tables Table</a>
        </li>
      </ul>

      <p><a href="#TopOfPage">[Go to top of page]</a>
      </p>
      <a id="preferences"></a>
      <h2>LogixNG Preferences</h2>

      <p>LogixNG has settings that can be set in JMRI <strong>Preferences &rArr; LogixNG</strong>.</p>

      <div style="margin-left: 2em">
        <a href="images/Preferences.png"><img src="images/Preferences.png" alt="LogixNG Preferences"></a>
      </div>

      <dl>
        <dt>Start LogixNGs on load</dt>

        <dd>If checked, the enabled LogixNG definitions will be active after the completion of the
        PanelPro xml data file loading. If not checked, the LogixNGs will be inactive until
        <strong>Tools &rArr; LogixNG &rArr; Start LogixNG</strong> is selected. The default setting is
        checked.</dd>

        <dt>Install Debugger</dt>

        <dd>There is an option in the LogixNG editor list for debugging a ConditionalNG. This has
        to be enabled during start up to work.</dd>

        <dt>Show system names and user names</dt>

        <dd>The LogixNG expressions and actions have names. These names are used internally by
        LogixNG. In certain developer situations, making the names visible can be helpful. The
        default is unchecked.</dd>

        <dt>Error Handling Options</dt>

        <dd>LogixNG has robust error handling. The combo box selection provides the default
        setting. Individual expressions and actions can override the default setting.</dd>
      </dl>

      <p>Note: LogixNG execution can be stopped using <strong>Tools &rArr; LogixNG &rArr; Stop
      LogixNG</strong>.</p>

      <p><a href="#TopOfPage">[Go to top of page]</a>
      </p>

      <p>&nbsp;</p>

      <p>&nbsp;</p>

      <p>&nbsp;</p>

      <hr>

      <hr>

      <hr>
      <a id="contents"></a>
      <h2>Contents</h2>

      <p>The documentation below describes LogixNG, and discusses how to set them up. The
      documentation is divided into sections; click below for easy access to a listed section. If
      you prefer to try before reading much, read <a href="#intro">Introduction to LogixNG</a>,
      then click <a href="#start">Getting Started</a> and follow those instructions. Return here to
      read about what you did.</p>

      <ul>
        <li>
          <a href="#intro">Introduction to LogixNG</a>
        </li>

        <li>
          <a href="#system_names">LogixNG system names</a>
        </li>

        <li>
          <a href="#logixng">What are LogixNG</a>
        </li>

        <li>
          <a href="#conditionalng">ConditionalNGs</a>
        </li>

        <li>
          <a href="#editconditionalng">The Edit ConditionalNG Window</a>
        </li>

        <li>
          <a href="#logicalexpression">The Logical Expression</a>
        </li>

        <li>
          <a href="#thepolicy">Triggering the Actions</a>
        </li>

        <li>
          <a href="#theactions">The Actions</a>
        </li>

        <li>
          <a href="#start">Getting Started</a>
        </li>

        <li>
          <a href="#enable">Enabled and Execution enabled</a>
        </li>

        <li>
          <a href="#notes">Additional Notes</a>
        </li>

        <li>
          <a href="#scripts">Scripts</a>
        </li>

        <li>
          <a href="#actions_expressions">List of actions and expressions</a>
        </li>
      </ul>

      <p>Detail <strong>State Variable</strong> and <strong>Action</strong> Lists:</p>

      <ul>
        <li>
          <a href=
          "../../package/jmri/jmrit/conditional/StateVariableActionList.shtml#variable">State
          Variables</a>
        </li>

        <li>
          <a href=
          "../../package/jmri/jmrit/conditional/StateVariableActionList.shtml#action">Actions</a>
        </li>
      </ul>

      <p>ConditionalNG Editor details:</p>

      <ul>
        <li>
          <a href=
          "../../package/jmri/jmrit/conditional/ConditionalNGListEditor.shtml">ConditionalNG List
          Editor</a>
        </li>

        <li>
          <a href=
          "../../package/jmri/jmrit/conditional/ConditionalNGTreeEditor.shtml">ConditionalNG Tree
          Editor</a>
        </li>
      </ul>
      <a id="intro"></a>
      <h2>Introduction to LogixNG</h2>

      <p>For those who have used Logix, it's important to note that LogixNG is similar, but
      different.</p>

      <p>The main building blocks in LogixNG are actions and expressions. An action does something,
      for example throwing a turnout, set a signal or run a script. An expression asks a question,
      for example if turnout LT2 is closed, or if sensor IS255 is active.</p>

      <p>The actions and expressions are organized in trees, there each tree is a ConditionalNG.
      The ConditionalNGs are organized in LogixNGs.</p>

      <p>An action or expression may have other actions and/or expressions as children, which
      allows the user to build a complex structure with simple building blocks.</p>

      <p>Example:<br>
      One common root of the tree is the <strong>IfThenElse</strong> action. It has one child
      expression and one or two child actions. It evaluates the expression and if the expression
      answers <strong>true</strong>, the <strong><em>then</em></strong> child action is executed.
      But if the expression answers <strong>false</strong>, the <strong><em>else</em></strong>
      child action is executed instead.</p>

      <p class="noted">LogixNG is both the name of the JMRI tool and the name of the main component
      of that tool.</p>
      <!--
      <a id="components"></a>
      <h2>LogixNG Components</h2>
      <dl>The three main components of the LogixNG tool are:
        <dt>LogixNG</dt>
        <dt>Module</dt>
        <dt>Table</dt>
      </dl>
 -->
      <!--
          <li>
        </ul>

       is the LogixNG table entry, its ConditionalNGs
      and the expressions and actions defined for the
 -->
      <a id="system_names"></a>
      <h2>LogixNG system names</h2>

      <p>System names in JMRI consists of a system prefix and a type letter. For LogixNG, the
      system prefix is usually 'I' and the type letter is 'Q'. But LogixNG consists of several
      subtypes and if all of them would have its own type letter, the letters in the alphabet would
      run out. Therefore, LogixNG has subtype letters, except for LogixNG itself.</p>

      <p>There is usually no need to work directly with system names and it's recommended to let
      JMRI to auto generate them. But they can be created manually if desired.</p>

      <p>LogixNG types and example system names</p>
      <!--      <table border="1" cellspacing="0"> -->

      <table>
        <tr>
          <th>LogixNG type</th>
          <th>System name</th>
          <th>Auto system name</th>
        </tr>

        <tr>
          <td>LogixNG</td>
          <td>IQ0001</td>
          <td>IQ:AUTO:0001</td>
        </tr>

        <tr>
          <td><strong>A</strong>nalog <strong>A</strong>ction</td>
          <td>IQAA0001</td>
          <td>IQAA:AUTO:0001</td>
        </tr>

        <tr>
          <td><strong>A</strong>nalog <strong>E</strong>xpression</td>
          <td>IQAE0001</td>
          <td>IQAE:AUTO:0001</td>
        </tr>

        <tr>
          <td><strong>C</strong>onditionalNG</td>
          <td>IQC0001</td>
          <td>IQC:AUTO:0001</td>
        </tr>

        <tr>
          <td><strong>D</strong>igital <strong>A</strong>ction</td>
          <td>IQDA0001</td>
          <td>IQDA:AUTO:0001</td>
        </tr>

        <tr>
          <td><strong>D</strong>igital <strong>B</strong>oolean action</td>
          <td>IQDB0001</td>
          <td>IQDB:AUTO:0001</td>
        </tr>

        <tr>
          <td><strong>D</strong>igital <strong>E</strong>xpression</td>
          <td>IQDE0001</td>
          <td>IQDE:AUTO:0001</td>
        </tr>

        <tr>
          <td><strong>S</strong>tring <strong>A</strong>ction</td>
          <td>IQSA0001</td>
          <td>IQSA:AUTO:0001</td>
        </tr>

        <tr>
          <td><strong>S</strong>tring <strong>E</strong>xpression</td>
          <td>IQSE0001</td>
          <td>IQSE:AUTO:0001</td>
        </tr>

        <tr>
          <td><strong>T</strong>able</td>
          <td>IQT0001</td>
          <td>IQT:AUTO:0001</td>
        </tr>
      </table>

      <p>"Auto system name" refers to system names that are generated automatically.</p>

      <p>All system names consists of the system prefix, the type letter, possible a subtype,
      possible :AUTO: and a number. The number may begin with zeros and the system name IQ1 is
      different from the system name IQ0001.</p>

      <p>The LogixNG data types Map and Table are used to make generic LogixNGs. For a table, its
      columns and rows can also be accessed as NamedBeans.</p>

      <h3>LogixNG table structure</h3>

      <p>A Table is a data type that holds a two-dimensional array, like a spreadsheet.</p>

      <p>Example:</p>

      <table>
        <tr>
          <th>
          </th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>D</th>
        </tr>

        <tr>
          <th>&nbsp;1&nbsp;</th>
          <td>IQT22</td>
          <td>Yard table</td>
          <td>
          </td>
          <td>
          </td>
        </tr>

        <tr>
          <th>&nbsp;2&nbsp;</th>
          <td>
          </td>
          <td>West yard</td>
          <td>East yard</td>
          <td>North yard</td>
        </tr>

        <tr>
          <th>&nbsp;3&nbsp;</th>
          <td>
          </td>
          <td colspan="3">Left entrance of the yard</td>
        </tr>

        <tr>
          <th>&nbsp;4&nbsp;</th>
          <td>Leftmost turnout</td>
          <td>IT101</td>
          <td>IT201</td>
          <td>IT301</td>
        </tr>

        <tr>
          <th>&nbsp;5&nbsp;</th>
          <td>Left turnout</td>
          <td>IT103</td>
          <td>IT203</td>
          <td>IT303</td>
        </tr>

        <tr>
          <th>&nbsp;6&nbsp;</th>
          <td>
          </td>
          <td colspan="3">Right entrance of the yard</td>
        </tr>

        <tr>
          <th>&nbsp;7&nbsp;</th>
          <td>Rightmost turnout</td>
          <td>IT112</td>
          <td>IT212</td>
          <td>IT312</td>
        </tr>

        <tr>
          <th>&nbsp;8&nbsp;</th>
          <td>Right turnout</td>
          <td>IT114</td>
          <td>IT214</td>
          <td>IT314</td>
        </tr>
      </table>

      <p>LogixNG can use references to access layout items like turnouts in an indirect way. It's
      done by entering the system name or user name in curly brackets. If a ActionTurnout has the
      turnout IT1, it will access that turnout directly. But if the ActionTurnout has the turnout
      {IM2}, it will read that memory and if that memory has a string as a value, it will use that
      string value to find the turnout. So if the memory IM2 has the value IT5, and the
      ActionTurnout has the turnout [IM2], the ActionTurnout will read the memory IM2 and find out
      that it points to the turnout IT5 and therefore do its action on turnout IT5. The benefit of
      this is that the Memory can be changed during execution and therefore the same ActionTurnout
      can be used to access different turnouts at different times.</p>

      <p>It's possible to use indirect access recursive. If a ActionTurnout has the turnout {IM5},
      and that Memory has the value {IM14}, and that the Memory IM14 has the value IT3, the
      ActionTurnout will access IT3. The ActionTurnout has an indirect turnout IM5, so it will read
      that Memory. And since that memory has the value {IM14} which also is an indirect access, it
      will read the memory IM14 and find out that it has the value IT3, and therefore use IT3. This
      is also true for tables. If the cell IQT1[5,3] has the value '{IM3}', and the memory IM3 has
      the value 'IT5', the cell IQT1[5,3] will point to IT5.</p>

      <p>A table can be used to create a lookup table. It's accessed by either its system name or
      its user name, followed by a left square bracket, the name of the column, a comma, the name
      of the row, and a right square bracket.</p>

      <p>Instead of the names of the row and column, it's also possible to use the row number or
      the column number. Note that row 1 has the system name and user name of the table, row 2 has
      the names of the columns, and column 1 has the names of the rows. Note that for columns, 1 is
      row A, 2 is row B, 22 is V, 23 is W, 26 is Z, 27 is AA and 28 is AB.</p>

      <p>Note that spreadsheet software, like Excel and LibreOffice Calc, has cell &lt;column
      letter&gt;&lt;row number&gt; while references in JMRI has table[row,column]. Example: Cell B3
      is table[3,2], since B3 is row 3 and column 2.</p>

      <p>Example from the table above. These examples assume that IM3 has the value 'West yard',
      IM4 has the value 'Rightmost turnout' and IM5 has the value 'IQT22'.</p>

      <table>
        <tr>
          <td>Cell</td>
          <td>Value</td>
          <td>Note</td>
        </tr>

        <tr>
          <td>IQT22[1,1]</td>
          <td>IQT22</td>
          <td>Cell A1 has the system name of the table</td>
        </tr>

        <tr>
          <td>IQT22[1,2]</td>
          <td>Yard table</td>
          <td>Cell B1 has the user name of the table</td>
        </tr>

        <tr>
          <td>IQT22[2,2]</td>
          <td>West yard</td>
          <td>Cell B2 has the name of column B</td>
        </tr>

        <tr>
          <td>IQT22[4,1]</td>
          <td>Leftmost turnout</td>
          <td>Cell A4 has the name of row 4</td>
        </tr>

        <tr>
          <td>Yard table[4,1]</td>
          <td>Leftmost turnout</td>
          <td>The user name of the table can be used to access the table</td>
        </tr>

        <tr>
          <td>IQT22[5,3]</td>
          <td>IT203</td>
          <td>Cell C5 has the value 'IT203'</td>
        </tr>

        <tr>
          <td>IQT22[Left turnout,North yard]</td>
          <td>IT303</td>
          <td>Column 'North yard' and row 'Left turnout' has the cell D5 with the value
          'IT303'</td>
        </tr>

        <tr>
          <td>Yard table[Left turnout,North yard]</td>
          <td>IT303</td>
          <td>Column 'North yard' and row 'Left turnout' has the cell D5 with the value
          'IT303'</td>
        </tr>

        <tr>
          <td>IQT22[Leftmost turnout,{IM3}]</td>
          <td>IT101</td>
          <td>IM3 is in curly brackets and have the value 'West yard' so this points to cell
          B4</td>
        </tr>

        <tr>
          <td>IQT22[{IM4},East yard]</td>
          <td>IT212</td>
          <td>IM4 is in curly brackets and have the value 'Rightmost turnout' so this points to
          cell C7</td>
        </tr>

        <tr>
          <td>IQT22[{IM4},{IM3}]</td>
          <td>IT112</td>
          <td>Column {IM3} and row {IM4} points to cell B7</td>
        </tr>

        <tr>
          <td>{IM5}[{IM4},{IM3}]</td>
          <td>IT112</td>
          <td>Even the table name can be accessed indirectly</td>
        </tr>
      </table>

      <p>Note that a Memory can point to a table. For example, if the memory IM7 has the value
      '{Yard table[{IM3},Leftmost turnout]}', LogixNG will look at IM7, and find that it's value is
      in curly brackets. It will then resolve the value inside these curly brackets, which is 'Yard
      table[{IM3},Leftmost turnout]'. It will then resolve the value of IM3 which has the value
      'West yard'. It will then get the table cell 'Yard table[West yard,Leftmost turnout]' which
      is cell B4 with the value 'IT101'.</p>

      <p>The ActionForEach iterates over a comma separated list of values. It can be used with
      tables by using the keywords __columns__ and __rows__ . Note that it's two underscore
      characters before and after. {IQT1[__columns__]} gives a comma separated list of all the
      column names in the table IQT1. {IQT1[__rows__]} gives a comma separated list of all the row
      names in the table IQT1. It's also possible to write {Yard table[__columns__]} and {Yard
      table[__rows__]}. You can even use this syntax in ActionMemory to assign a Memory the list of
      column names or row names. Note however that column names or row names that are empty is seen
      as columns or rows with a comment, and therefore they are not included.</p>

      <p>Tables are loaded by a start up action. They are created in a spreadsheet, like Microsoft
      Excel or LibreOffice Calc and then exported to a CSV file, separated by TAB characters. The
      table is read only and is not stored in the panel filee, so it must be reloaded each time
      JMRI starts.</p>

      <h3>Note</h3>

      <p>If a name has the characters comma, left or righ square bracket or left or right curly
      brackets, these characters must be escaped by preceding them with a backslash. Examples: \,
      \[ \] \{ \} \\</p>

      <p>If a reference contains a backslash, it will take some more time to evaluate it than if it
      doesn't contain any backslash. So if it's possible to not use these special characters in
      references or names of beans, it's recommended.</p>
      <!--      <h3>Important</h3>

          <p>In order for indirect access to work, some limitations are put on the names
          used in LogixNG. System names and user names must not contain comma, square brackets
          and curly brackets. For example, if a turnout has the name 'Green yard, left turnout',
          it cannot be used with its user name in LogixNG unless the name is changed and the
          comma is removed.</p> -->
      <a id="logixng"></a>
      <h2>What are LogixNG?</h2>

      <p>If a LogixNG is enabled and not is being created or edited, a LogixNG is "active", which
      means that the entities (turnouts, sensors, lights, etc.) in logical expressions of the
      LogixNG's ConditionalNGs are being monitored. Whenever the state of any of the monitored
      entities of a ConditionalNG changes, that ConditionalNG "calculates" its logical expression.
      If the result of the calculation changes the value of the logical expression, then the
      specified actions of the ConditionalNG are taken.</p>

      <h3>The LogixNG Table</h3>

      <p>A LogixNG is defined via the <a href=
      "../../package/jmri/jmrit/beantable/LogixNGTable.shtml">LogixNG Table</a> that can be
      accessed by selecting <strong>LogixNG Table</strong> in the Tools menu. The LogixNG Table
      lists all currently defined LogixNG by their System Name and User Name. The table also shows
      whether a LogixNG is "Enabled". The last column of the table provides an easy way to edit a
      LogixNG and its ConditionalNGs. Clicking the <strong>Select</strong> choice box for a
      LogixNG, will drop down a menu with four choices: <strong>Edit</strong>,
      <strong>Browse</strong>, <strong>Copy</strong> and <strong>Delete</strong>.<br>
      Each choice will bring up a pane for the corresponding operation.</p>

      <h4>LogixNG Table controls</h4>

      <ul>
        <li>Below the LogixNG Table is the <strong>Add...</strong> button.</li>

        <li>The Options menu has three sections:
          <ul>
            <li>The first section lets you <strong>Enable</strong> or <strong>Disable</strong> all
            LogixNGs.</li>

            <li>The second section lets you select a user name selection method. See the <a href=
            "../../package/jmri/jmrit/beantable/LogixNGTable.shtml#logixOptions">LogixNG
            Options</a> menu for details.
            </li>

            <li>The third section lets you select a ConditionalNG Editor. See the <a href=
            "../../package/jmri/jmrit/beantable/LogixNGTable.shtml#logixOptions">LogixNG
            Options</a> menu for details.
            </li>
          </ul>
        </li>

        <li>The Tools menu contains five LogixNG maintenance tools:
          <ul>
            <li>Open picklist tables</li>

            <li>Find orphaned items</li>

            <li>Find empty ConditionalNGs</li>

            <li>Find Cross References</li>

            <li>ConditionalNG Variable References<br>
              <a href="../../package/jmri/jmrit/beantable/images/VariableReferences.png"><img src=
              "../../package/jmri/jmrit/beantable/images/VariableReferences.png" alt=
              "Variable Reference Window"></a>
            </li>
          </ul>
        </li>
      </ul>

      <h3>Creating a new LogixNG</h3>

      <p>To create a new LogixNG, click the <strong>Add...</strong> button at the bottom of the
      LogixNG Table pane. This will bring up a Create LogixNG window. Entering a System Name and a
      User Name, then clicking <strong>Create LogixNG</strong>, will create the LogixNG, and bring
      up the Edit LogixNG window. This window allows ConditionalNGs to be created and edited. Once
      a LogixNG is created, its System Name cannot be changed. Its User Name, however, may be
      changed in either the LogixNG Table or the Edit LogixNG window. A new User Name may be any
      useful text, provided the new User Name was not previously assigned to another LogixNG.</p>

      <p>A LogixNG is named using the JMRI convention. The System Name for the LogixNG always must
      begin with the two letters IX and is usually followed by a number selected by the user. For
      example, valid LogixNG System Names include: IX1, IX34, and IX100. The user name is whatever
      the user wants to use to identify the particular LogixNG, for example, "Signal 5 Control". As
      a convenience to the user, if the entered System Name does not begin with IX, the program
      will add IX in front of what is entered. For example, to enter a System Name of IX32, simply
      enter 32 in the System Name field, and the program will do the rest.</p>

      <p>The Edit LogixNG window displays the System Name and User Name of the LogixNG at the top.
      The User Name may be changed by entering/modifying the text in the User Name field. Next is a
      table of ConditionalNGs belonging to the LogixNG. To add a new ConditionalNG, click the
      <strong>New ConditionalNG</strong> button under the ConditionalNG Table. This will create a
      new ConditionalNG and open the Edit ConditionalNG window allowing the logical expression and
      actions of the new ConditionalNG to be defined. An existing ConditionalNG may be edited by
      clicking the <strong>Edit</strong> button of that ConditionalNG in the table. The User Name
      of the ConditionalNG may be changed in the table. The User Name of a ConditionalNG may be any
      useful text, provided it is not the same as the User Name of another ConditionalNG in the
      same LogixNG. The User Name may be the same as the User Name of a ConditionalNG in another
      LogixNG. <em>When editing the User Name (or any item in any JMRI table) please remember to
      move to another cell in the table so that the program is notified that you have finished your
      entry, otherwise the entry may not take effect.</em></p>

      <p>Clicking <strong>Calculate</strong> under the ConditionalNG Table causes all
      ConditionalNGs of the LogixNG to be calculated. Resulting states are displayed in the State
      column of the table. However, since the LogixNG is being edited it is inactive and therefore
      no ConditionalNG actions are taken. When the editing of the LogixNG is done, the LogixNG is
      activated and may be enabled to allow ConditionalNGs to execute their actions.</p>

      <p>The order of ConditionalNGs in the ConditionalNG Table may be changed by clicking
      <strong>Reorder</strong> (below the ConditionalNG Table). Clicking <strong>Reorder</strong>
      changes all edit buttons in the last Column of the table to <strong>First</strong>. Select
      the ConditionalNG that is to be first, and it is immediately moved to the top of the table.
      All remaining buttons change to <strong>Next</strong>. Select remaining ConditionalNGs in
      desired order, until all buttons change back to <strong>Edit</strong>.</p>

      <p>The only time when the ConditionalNGs are evaluated in the order listed is when all of
      their states are UNKNOWN, such as when the LogixNG is being enabled. ConditionalNGs are
      evaluated when one of their expressions changes its state. If an entity is used as an
      expression in more than one conditionalNG, it is indeterminate which conditionalNG is
      evaluated first.</p>

      <p>When <strong>Done</strong> is clicked at the bottom of the Edit LogixNG window, any change
      in the LogixNG User Name is checked and made. A check is made for inconsistencies in
      specifying that an entity (sensor, turnout, etc.) referenced in multiple expressions is not
      monitored as a trigger for calculation of the LogixNG, and a warning message appears if any
      inconsistencies are found. Then the LogixNG is activated, the Edit LogixNG window is
      dismissed, and the user is returned to the LogixNG Table. Immediately before the LogixNG is
      activated, the state of all its ConditionalNGs is set to UNKNOWN. Immediately after
      activation, all ConditionalNGs are calculated.</p>

      <p>The Edit LogixNG window also provides a way to delete a LogixNG if it is no longer needed.
      Click <strong>Delete LogixNG</strong> to delete the LogixNG being edited and all its
      ConditionalNGs. This operation can also be done by selecting the <strong>Delete</strong> item
      from the drop down <strong>Select</strong> menu on the LogixNG Table.</p>

      <p>Selecting the <strong>Browse</strong> item from the drop down menu on the LogixNG Table
      will open a window with a list showing the details for each conditionalNG. It is an effective
      way to review the entire contents of a LogixNG. Click on the close button to close the
      window.</p>

      <div style="margin-left: 2em">
        <a href="../../package/jmri/jmrit/beantable/images/ConditionalNGBrowser.png"><img src=
        "../../package/jmri/jmrit/beantable/images/ConditionalNGBrowser.png" alt=
        "ConditionalNG Browser Window"></a>
      </div>

      <p>Selecting the <strong>Copy</strong> item from the drop down <strong>select</strong> menu
      on the LogixNG Table will show a series of dialog windows that provide a way to copy the
      LogixNG and any or all of its ConditionalNG to a new or existing LogixNG.</p>

      <a id="conditionalng"></a>
      <h2>ConditionalNGs</h2>

      <p>A ConditionalNG's System Name has the form IXnnnnCmm, and is set automatically when the
      ConditionalNG is created by the user clicking <strong>New ConditionalNG</strong> in the Edit
      LogixNG window. The System Name of the first ConditionalNG for LogixNG IXnnn will always be
      IXnnnC1, the second ConditionalNG will have System Name IXnnnC2, and so on. The User Name of
      a ConditionalNG is whatever the user wants to assign to identify the use of the
      ConditionalNG. An entered User Name must not be used by more than one ConditionalNG within a
      given LogixNG, however. The System Name and User Name are displayed at the top of the Edit
      ConditionalNG window. The User Name may be entered/edited there or in the ConditionalNG Table
      of the Edit LogixNG window. The User Name of a ConditionalNG may be any useful text, provided
      it is not the same as the User Name of another ConditionalNG in the same LogixNG. The user
      name may be the same as the User Name of a ConditionalNG in another LogixNG.</p>

      <p>As mentioned above, ConditionalNGs are statements of the form:</p>

      <div style="margin-left: 2em;">
        <p><code>if (antecedent) then (consequent).</code>
        </p>
      </div>

      <p>Therefore a ConditionalNG has two distinct parts: its "logical expression" and its
      "actions". These are discussed separately below.</p>

      <p>Logical expressions connect the states (true or false) of "expressions". State variables
      test conditions on the layout or in the program, for example, if a sensor is active or
      inactive, if a turnout is closed, if a signal head is red, if the fast clock time is between
      10:00 and 11:00, etc. State variables are linked together in a logical expression by logic
      operators. For a list of currently available expressions, see <a href=
      "../../package/jmri/jmrit/beantable/ConditionalNGAddEdit.shtml#variable">State
      Variables</a></p>

      <p>Logic operators currently available are NOT, AND, AND NOT, OR and OR NOT. The AND operator
      is set up automatically by the program. For each expression, the user selects whether the NOT
      operator is to precede the expression. If the NOT operator precedes the expression, the
      true/false value of the expression is reversed. For example, if "Sensor Active CS5" is true,
      "NOT Sensor Active CS5" will be false, and vice versa. Note that "Sensor Active CS5" is
      sometimes not the same as "NOT Sensor Inactive CS5", because Sensor CS5 may be in the UNKNOWN
      state.</p>

      <p>Logical expressions read like written statements. It is easy to set up a logical
      expression to evaluate many situations on the layout. For example, "if block 10 and block 11
      are occupied and turnout 20 is thrown" would be set up as:</p>

      <ul>
        <li><code>Sensor "LS1020" is Sensor Active AND Sensor "LS1021" is Sensor Active AND Turnout
        "LT20" is Turnout Thrown</code>
        </li>
      </ul>

      <p>where LS1020 is a sensor that is true when block 10 is occupied (perhaps from a BDL168),
      sensor LS1021 is true when block 11 is occupied, and Turnout Thrown LT20 is true when turnout
      LT20 is thrown. This logical expression would calculate to true if all three of the
      expressions are true, i.e., if block 10 is occupied AND block 11 is occupied AND turnout 20
      is thrown; otherwise it would calculate false.</p>

      <p>Actions may be specified for each ConditionalNG. A number of action types are available.
      For example, Set Turnout, Set Signal Appearance, Trigger Route, etc. For a list of currently
      available action types, see <a href=
      "../../package/jmri/jmrit/beantable/ConditionalNGAddEdit.shtml#action">Actions</a>. Each
      action has a user selectable option of being performed if: 1) the logical expression changes
      to true, 2) the logical expression changes to false, or 3) the logical expression changes.
      This means a conditionalNG may actually be three statements.</p>

      <ul>
        <li>if (antecedent is true) then (do "on change to true" actions)</li>

        <li>if (antecedent is false) then (do "on change to false" actions)</li>

        <li>if (antecedent state changes) then (do "on change" actions)</li>
      </ul>
      <a id="editconditionalng"></a>
      <h3>The Edit ConditionalNG Window</h3>

      <p>The Edit ConditionalNG window is where logical expressions are set up and where actions
      are specified. The Edit ConditionalNG window is displayed when a ConditionalNG is created, or
      when the <strong>Edit</strong> button of a ConditionalNG is pressed in the Edit LogixNG
      window. The Edit ConditionalNG window displays the System Name and User Name of the
      ConditionalNG at the top. The User Name may be edited by entering/modifying the text in the
      User Name field. Any text may be used, provided it doesn't duplicate the user name of another
      ConditionalNG in the same LogixNG. Next are two sections--one for the setup of a logical
      expression and one for set up of the actions.</p>
      <a id="logicalexpression"></a>
      <h3>The Logical Expression</h3>

      <p>The logical expression section contains a table of state variables, with two buttons and a
      dropdown menu box below. The dropdown menu allows the choice of what logical operators to
      use in the antecedent. The choices are: all <strong>AND</strong>'s, all <strong>OR</strong>'s
      or <strong>Mixed</strong>. Mixed allows the user to specify any combination of AND's, OR's
      and NOT's. When this choice is made the logical expression requires parentheses in order to
      be unambiguous. So, when this choice is made, a text field is displayed so that parentheses
      can be inserted and the expression modified. The expressions are represented in the
      expression by their row number.</p>

      <p>The first column in the expression table is the row number of the variable. The next
      column displays the logic operation preceding the variable in the expression. In the case of
      "Mixed" a choice box allows the user to choose an operation. However, these choices can be
      changed in the antecedent text field. It is the text field expression that the
      ConditionalNG uses to determine its state. The third column contains a choice box that allows
      the user to select the NOT operator as needed.</p>

      <p>The fourth column is a description of expression and the condition to be monitored to be
      for its state to be true. The next column shows the state that was last tested for the
      variable (true or false). The state displayed includes the effect of the NOT operator, if NOT
      is selected.</p>

      <p>The "Trigger" column sets whether the expression should cause the ConditionalNG to perform
      its actions when this variable changes. Note that the current states of all the variables are
      <strong>always</strong> used in the calculation of the ConditionalNG's state. The "Trigger"
      setting allows a state variable to be "passive" and not cause the conditionalNG to evaluate
      its state. That is, such a variable state is a necessary condition, but not a sufficient one
      to cause any actions to take place.</p>

      <p><strong>Note:</strong> Disabling expression triggers should be done with caution. Actions
      are performed only when the state of the logical expression changes. Disabling a trigger can
      prevent actions from be executed even when this state has changed.</p>

      <p>Next is a column of <strong>Edit</strong> button to modify an existing expression. The
      last column of the table (<strong>Delete</strong> buttons) is used to delete a expression if
      you decide it is no longer needed.</p>
      <a id="variable"></a>
      <p>Press the <strong>Add State Variable</strong> to add a state variable (a row in the State
      Variable table). This brings up a window with a choice box for the user to select a state
      variable type. Available expressions are documented at <a href=
      "../../package/jmri/jmrit/beantable/ConditionalNGAddEdit.shtml#variable">State Variables</a>.
      When a type is chosen the Edit Variable window displays a text field for the name of the
      entity to be used for the expression. When a name (either System Name or user name) is
      entered, it must correspond to an existing entity (sensor, turnout, light, etc.). Depending
      on your <a href=
      "../../package/jmri/jmrit/beantable/LogixNGTable.shtml#selectMethod">selection method</a>, a
      tabbed Pick List, a single Pick List or a dropdown combo box will be displayed to aid in name
      selection.</p>

      <p>At any time during the entry of expression data, the <strong>Check State
      Variables</strong> button may be clicked to check the entered data and evaluate the
      expressions. When this button is pressed, the checking and evaluation proceeds until the
      check completes successfully, or an error is detected. If an error is detected, the checking
      stops for the user to correct the error and click <strong>Check State Variables</strong>
      again. <em>Please remember after editing the System Name and data items to click a different
      cell in the table before clicking <strong>Check State Variables</strong> (or <strong>Update
      ConditionalNG</strong> at the bottom of the window) so that the program is notified that you
      have finished your entry. Otherwise, your entry may not take effect, and an error may be
      reported unnecessarily.</em></p>
      <a id="thepolicy"></a>
      <h3>Triggering the Actions</h3>

      <p>There are two policies that can be taken after a conditionalNG's state is evaluated:</p>

      <ul>
        <li>Execute the conditionalNG actions only if the state of the conditionalNG has
        changed</li>

        <li>Execute the conditionalNG actions regardless whether the state has changed</li>
      </ul>

      <p>Which policy to use is chosen by the radio buttons in the middle of the Edit ConditionalNG
      window. The <strong>Execute actions on change of state only</strong> button prevents unwanted
      behavior from occurring when multiple instances of the "on true" or "on false" actions are
      executed. That is, if successive triggers cause the logical expression to be evaluated to the
      same state, only the first trigger will execute the actions. Normally, it is best for a
      conditionalNG to execute its actions only when the state of the conditionalNG changes.
      However, if it is important to maintain the actions associated with a particular state of the
      ConditionalNG the <strong>Execute actions whenever triggered</strong> button should be used.
      If external events undo some of the actions of the conditionalNG but do not change the state
      of the conditionalNG, then this policy will execute the action on any trigger.</p>
      <a id="theactions"></a>
      <h3>The Actions</h3>

      <p>The Actions section of the Edit ConditionalNG window contains a table of actions, with two
      buttons below for adding a new action and reordering the list of actions. The section
      provides for specifying the actions to be taken when a ConditionalNG is calculated and
      changes its state. The action table consists of a column for the description of the action to
      be taken and two columns of buttons, <strong>Edit</strong> and <strong>Delete</strong>, for
      editing or deleting an existing action. To add a new action, press the "Add Action" button. A
      new "Edit Action" window will appear. Select an action type in the type box, and data items
      needed to completely specify the action will appear to the right of the type box. When a name
      must be entered, the name must correspond to the System Name or the User Name of an existing
      entity (sensor, turnout, signal head, etc.) of the proper type. Depending on your <a href=
      "../../package/jmri/jmrit/beantable/LogixNGTable.shtml#selectMethod">selection method</a>, a
      tabbed Pick List, a single Pick List or a dropdown combo box will be displayed to aid in name
      selection. Available action types are described in detail at <a href=
      "../../package/jmri/jmrit/beantable/ConditionalNGAddEdit.shtml#action">Actions</a>. <em>If
      you use User Names to specify your actions, the same caution noted above applies. Be very
      careful when editing User Names that are used to specify actions.</em></p>

      <p>For each action, three options are available for when to perform the action: 1) On Change
      to True, 2) On Change to False, and 3) On Change. These refer to the calculated state of the
      ConditionalNG, which is equal to the value of the logical expression as specified in the
      expression table. One of these options must be selected. When done, click either "Update" to
      install your changes, "Cancel" to close the window without any changes or "Delete" to remove
      the action entirely.</p>

      <p>To change the order order of the ConditionalNGs in a LogixNG, or the order of the actions
      in a conditionalNG click the "Reorder" button. The right-most buttons in the table will then
      let you select the first one, next one, etc. Note however, this is merely the order in which
      the commands are issued but do not guarantee that their final effect will occur in the same
      order. If it is necessary to have actions take place in a specified order, use separate
      ConditionalNGs for each action and chain the ConditionalNGs such that a preceding action's
      completed state is the expression for the succeeding action.</p>
      <a id="updateconditionalng"></a>
      <h3>Activating the ConditionalNG</h3>

      <p>When the logical expression and actions have been specified, click <strong>Update
      ConditionalNG</strong> at the bottom of the window. This initiates a check of the logical
      expression (the same as done by <strong>Check State Variables</strong>) and a check of
      entered data for actions. If the ConditionalNG's User Name has been edited, it is also
      checked. If an error is found, a message box opens announcing the error, and the update is
      stopped to allow the user to correct the error and click <strong>Update
      ConditionalNG</strong> again. If no error is found, the ConditionalNG is updated with the
      entered data, the Edit ConditionalNG window is closed, and the user is returned to the Edit
      LogixNG window.</p>

      <p>Two other buttons are available at the bottom of the Edit ConditionalNG window. Clicking
      <strong>Cancel</strong> will close the Edit ConditionalNG window without updating the
      ConditionalNG. Clicking <strong>Cancel</strong> results in loss of any data that has been
      entered. The other button, <strong>Delete ConditionalNG</strong>, provides an easy way to
      delete an unneeded ConditionalNG. Click <strong>Delete ConditionalNG</strong> to delete the
      ConditionalNG being edited and return to the Edit LogixNG window.</p>
      <a id="start"></a>
      <h2>Getting Started</h2>

      <p>The following steps let you create your first LogixNG and become familiar with how the
      LogixNG user interface works.</p>

      <ol>
        <li>Select Table -&gt; <strong><a href=
        "../../package/jmri/jmrit/beantable/LogixNGTable.shtml">LogixNG</a></strong> in the
        <strong>Tools</strong> menu.</li>

        <li>Click the <strong><a href=
        "../../package/jmri/jmrit/beantable/LogixNGAddEdit.shtml">Add...</a></strong> button below
        the LogixNG Table.</li>

        <li>In the Create LogixNG window that appears, enter 6 for System Name, and "test" for User
        Name, then click <strong>Create LogixNG</strong>.</li>

        <li>In the Edit LogixNG window that appears, click <strong>New ConditionalNG</strong>.</li>

        <li>In the Edit ConditionalNG window that appears, click <strong>Add State
        Variable</strong> to begin defining a logical expression for the ConditionalNG.</li>

        <li>In the new window that appears, click the "Variable Type" choice box to reveal a
        scrolling selection box. Select "Sensor".</li>

        <li>Note that a text field appears asking for entry of a sensor name. Enter the name
        (either System Name or User Name) of any of your existing sensors. (If you don't have an
        existing sensor, select <strong>Sensor Table</strong> in the <strong>Tools</strong> menu
        and create one.) Select <strong>Inactive</strong> from the Variable State drop down.</li>

        <li>Click the <strong>Update</strong> button and note the row entries that appear in the
        expression table.</li>

        <li>Click <strong>New State Variable</strong> to create another row in the table. Note that
        AND appears in the first column of the new row. Again select "Sensor" as the variable type,
        and enter the name and desired state of a different sensor (create it if needed).</li>

        <li>Click the third column entry of the second row to reveal the selection box for NOT.
        Select NOT, then click <strong>Check State Variables</strong> again. Note that the State of
        the second expression has reversed.</li>

        <li>For an Action click <strong>Add Action</strong>.</li>

        <li>In the new window that appears, click the "Action Type" choice box to reveal a
        scrolling selection box. Select "Turnout", and enter the name (System Name or User Name) of
        one of your turnouts. (If you don't have any turnouts, create one using the
        <strong>Add</strong> button in the Turnout Table.) Select <strong>Set Turnout</strong> for
        the Action Type, leave the "Turnout Position" option at "Closed" and "Change Option" at "On
        Change to True".</li>

        <li>Click the <strong>Update</strong> button and note the row entries that appear in the
        action table.</li>

        <li>For another Action - again click <strong>Add Action</strong> and select "Turnout".
        Enter the name of the same turnout entered before. Select "On Change to False" as the
        Trigger Option, and "Thrown" as the Turnout Position.</li>

        <li>Click <strong>Update</strong> to close the Edit ConditionalNG window and return to the
        Edit LogixNG window.</li>

        <li>Click <strong>Done</strong> to close the Edit LogixNG window and activate your new
        LogixNG. Click <strong>OK</strong> in the reminder-to-save dialog that appears.</li>
      </ol>

      <p>You'll have created a LogixNG to control the setting of a turnout according to the states
      of two sensors. It's as simple as that. It took you more time to read this tutorial than to
      create the LogixNG.</p>

      <h3>Saving LogixNG to disk</h3>

      <p>LogixNG are kept in your <em>layout configuration</em>, along with Turnouts, Sensors,
      Signal Heads, control panel setup etc. To store this information on disk, allowing to
      <a href="../../package/jmri/jmrit/display/PanelMenuHelp.shtml">reload it</a> next time you
      run JMRI, use <strong>Store Configuration...</strong> in the <strong>File</strong> menu at
      the top of the LogixNG Table (or other tables from the Tools menu), or select <strong>Store
      Panel...</strong> in the <strong>Panel</strong> menu. Note that the enabled/disabled state of
      each LogixNG is saved in the configuration file.</p>
      <a id="enable"></a>
      <h2>Enabled and Execution enabled</h2>

      <p>The intention with LogixNG is to be similar to Logix, in order to make it easier for users
      of Logix to understand how LogixNG works.</p>

      <p>This has resulted in a big challenge when it comes to <strong>Enabled</strong>, since in
      Logix, a Conditional that is not <strong>Enabled</strong> will still calculate its variables
      but not execute its actions.</p>

      <p>In LogixNG, there is a need to be able to completely disable the calculation too, and not
      only the execution of actions. Therefore, in LogixNG, if a LogixNG or a ConditionalNG is not
      <strong>enabled</strong>, it's not evaluated at all.</p>

      <p>But LogixNG also needed to be somewhat compatible with Logix, for example to be able to
      import Logixs to LogixNG. In order to solve that, LogixNG has <strong>execution
      enabled</strong>. If a LogixNG or a ConditionalNG doesn't have <strong>execution
      enabled</strong>, it's only evaluated but not executed.</p>

      <p>There is however a problem with <strong>execution enabled</strong> . Not all of the
      actions supports this. Only the actions <a href="#aaa">IfThenElse</a> and <a href=
      "#bbb">Logix</a> supports <strong>execution enabled</strong>.</p>
      <a id="notes"></a>
      <h2>Additional Notes</h2>

      <p>This section contains questions and answers that normally are not needed by LogixNG users,
      but in some cases were important or of interest using previous versions of LogixNG.</p>

      <ul>
        <li>
          <p><strong>How is a LogixNG started?</strong>
          </p>

          <p>Start of a LogixNG is similar to the way a light, a route, or other continuously
          running JMRI entity starts. Internally a LogixNG has an "activate" method, that is called
          when the LogixNG is created, after it is edited, or when it is loaded from a
          configuration file. This method starts listeners for items in the expressions of the
          LogixNG's ConditionalNGs. When any of these listeners fires (indicating that the watched
          property of an expression has changed), the LogixNG is calculated, resulting in
          appropriate actions being taken, provided the LogixNG is enabled.</p>
        </li>

        <li>
          <strong>When should Triggers Calculation be unchecked in an expression?</strong>
          <p>Normally Triggers Calculation should be checked in all expressions that has this
          option, so a change in any of its expression will trigger calculation of a LogixNG. This
          results in the LogixNG quickly reacting to changes on the layout, and maintaining the
          status of signals, turnouts, etc. as desired. There are situations, however, where it is
          desirable to test the state of an entity, but not use it as a calculation trigger. The
          following paragraphs describe a couple of those situations, but there are others.</p>

          <p>Occasionally a "logic loop" can result if triggering is not suppressed. For example,
          if the state of a turnout is tested in an expression, and the same turnout is set in an
          action of the same or another ConditionalNG of the same LogixNG, continuous triggering (a
          logic loop) could result. The easiest way out of this dilemma is to test the turnout,
          without using it as a triggering entity. This is done by unchecking Triggers Calculation
          in <strong>all</strong> expressions where the turnout is specified. If the turnout is
          used in expressions of more than one ConditionalNG of the LogixNG, it must be unchecked
          everywhere it is used to suppress using it as a trigger.</p>

          <p>Another situation arises when Delayed Set Sensor action is used with an internal
          sensor to trigger a second LogixNG after the delay time has elapsed. If the second
          LogixNG is not to be triggered before the delay time elapses, all of its expressions,
          except for the delayed internal sensor, should be unchecked. This scenario might occur,
          for example, if a ConditionalNG turns on something as its first action, and sets a
          Delayed Set Sensor as its second action to turn off that something after a specified time
          provided certain conditions are met.</p>
        </li>

        <li>
          <strong>What is a "logic loop" and how can it be avoided?</strong>
          <p>A "logic loop" results when the program appears to slow down significantly or lock up
          as multiple LogixNGs are continuously triggered by changing references to each other. The
          best way to avoid a "logic loop" is to be aware of situations that can lead to a loop,
          and plan your logic to avoid such situations.</p>

          <p>A "logic loop" can result within a single LogixNG when an expression (sensor, turnout,
          etc.) that triggers the LogixNG is also changed by that same LogixNG. The LogixNG editor
          will detect some situations that could result in a loop, and will issue a warning when
          you close the LogixNG. <strong>Heed these warnings!</strong> A warning doesn't mean that
          a loop definitely will result if you continue. The warning message is a "wake-up call"
          that you should study carefully what you're doing to make sure a loop won't result.</p>

          <p>A more complicated situation involving two or more LogixNGs can also result in a
          "logic loop". For example, if LogixNG 1 is triggered by sensor A, and has an action that
          changes turnout B, and LogixNG 2 is triggered by turnout B and changes sensor A, the
          potential for a loop exists as these LogixNGs trigger each other. You can easily extend
          this idea to triggering chains (loops) involving three or more LogixNGs, and even to
          interactions between LogixNGs and Routes. There is no test in the program to warn about
          loops involving multiple LogixNGs. (To develop such a test would be very difficult.)</p>
        </li>

        <li>
          <strong>What should I do if I think I have a "logic loop"?</strong>
          <p>When they do occur, "logic loops" can be a bit scary to trouble shoot. Your computer
          may appear to be locked up, or slowed to a crawl as the loop uses up most of the
          available computer time. Fortunately JMRI provides tools to help in design and debugging.
          Unchecking "Triggers Calculation" for an expression (discussed above), can help you design
          around loops when you have identified the LogixNG causing the looping problem. To get
          around the lockup or slow down problem, start with all your LogixNGs disabled, (see
          below) then enable them one by one until you discover the loop.</p>

          <p>If the panel file containing LogixNGs loads automatically when the program starts up,
          press and release the shift key a few times rapidly as soon as you see the small JMRI
          splash screen (the first thing you see during start up). Your panel file will be loaded
          with all LogixNGs disabled.</p>

          <p>If you load your panel file manually using the Panels &gt; Open Panel... menu, before
          loading your file, go to the <strong>Debug</strong> menu and select <strong>Load LogixNGs
          Disabled</strong>. After responding OK to the message, load your panel file as you
          normally would. Your panel file will be loaded with all LogixNGs disabled.</p>

          <p>After loading your panel file, open the LogixNG Table and verify that all LogixNGs are
          disabled. If you know which LogixNG is causing the trouble, you can then fix it or delete
          it, re-enable the other LogixNGs, and save your panel file. If you don't know which
          LogixNG is causing the problem, you can enable your LogixNGs, one by one, until the loop
          occurs. When the loop starts, you know that the last LogixNG you enabled is at least
          partly responsible for the problem. At this point you should restart the program with all
          LogixNGs disabled, and fix or delete the LogixNG you identified.</p>

          <p><strong>CAUTION:</strong> <strong>It's wise to save your panel file frequently when
          entering LogixNGs.</strong> If a logic loop occurs, it may be difficult, if not
          impossible, to save your panel file before shutting down the program. Remember that a
          LogixNG is activated as soon as you click <strong>Done</strong> in the Edit LogixNG
          window. Also, remember that hitting an <strong>Edit</strong> button in the LogixNG Table
          deactivates the selected LogixNG before opening it for editing, offering a possible way
          to break into a logic loop without restarting the program.</p>
        </li>
      </ul>
      <a id="scripts"></a>
      <h2>Scripts</h2>

      <p>All types of LogixNG actions and expressions may use Python/Jython scripts. Below follows
      the description of scripts for digital expressions, but the same pattern applies to all the
      types of actions and expressions.</p>

      <p>The digital expression that handles scripts is ExpressionScript.</p>

      <p>The script that is executed by ExpressionScript must declare a class that extend the class
      AbstractScriptDigitalExpression. The script must override the method evaluate(). For a script
      that listen to other beans, it's recommended to also override the methods
      registerScriptListeners() and unregisterScriptListeners().</p>

      <p>When called, the script must tell the caller which class to use. It does that by setting
      the variable params._scriptClass.set(instance)</p>

      <p>Example of a digital expression script:</p>

      <div style="margin-left: 2em;">
        <p><code>import jmri<br>
        <br>
        class
        MyExpression(jmri.jmrit.logixng.digital.expressions.AbstractScriptDigitalExpression):<br>
        <br>
        &nbsp;&nbsp;l = lights.provideLight(\"IL1\")<br>
        <br>
        &nbsp;&nbsp;def registerScriptListeners(self):<br>
        &nbsp;&nbsp;&nbsp;&nbsp;self.l.addPropertyChangeListener(\"KnownState\", self);<br>
        <br>
        &nbsp;&nbsp;def unregisterScriptListeners():<br>
        &nbsp;&nbsp;&nbsp;&nbsp;l.removePropertyChangeListener(\"KnownState\", this);<br>
        <br>
        &nbsp;&nbsp;def evaluate(self):<br>
        &nbsp;&nbsp;&nbsp;&nbsp;return self.l.commandedState == ON<br>
        <br>
        params._scriptClass.set(MyExpression(params._parentExpression))<br></code>
        </p>
      </div>
      <a id="indirect_accessing"></a>
      <h2>Indirect adressing of NamedBeans</h2>

      <p>In some cases, it may be useful to use indirect addressing of NamedBeans.</p>

      <p>This can be done in two ways:</p>

      <ul>
        <li>Using a Memory that has the name of the NamedBean</li>

        <li>Using a NamedBeanMap to look up the name of the NamedBean</li>
      </ul>

      <p>Using a Memory that has the name of the NamedBean</p>

      <p>Lets say we have an ActionTurnout that should throw a particular turnout. But we want to
      be able to select which turnout to throw at a later time. We can solve that by storing the
      system name or user name in a Memory. We then tell the ActionTurnout to read the Memory and
      lookup the turnout on the fly.</p>

      <p>Since LogixNG fully supports string manipulation and calculations of both integers and
      floating point values, where are plenty of possibilities here.</p>

      <h3>Warning</h3>

      <p>There is one major drawback with this. Since LogixNG doesn't know in advance which
      NamedBeans will be accessed indirectly, it's not possible for LogixNG to automatically register
      listeners to the named beans that should trigger on change. For example, an ExpressionTurnout
      registers a listener on the turnout, if the name of the turnout is given, but if the
      ExpressionTurnout is using indirect addressing of the turnout, it's not able to do that.</p>

      <p>The solution is to use the ActionListenOnBeans and tell this action which beans to listen
      on. Any time any property of any of the named beans this action listens to changes, the
      ConditionalNG will be executed.</p>

      <p>Example:</p>

      <p>A ConditionalNG is using turnouts IT1, IT2, IT3, IT4 and IT5 in its expressions and wants
      each of them to trigger on change. Turnouts IT1 and IT3 and IT4 are directly accessed in
      expressions and IT2, IT3 and IT5 is indirect accessed.</p>

      <p>The ConditionalNG will automatically listen to each turnout that is directly addressed in an
      expression, so IT1, IT3 and IT4 will be listened to. But in order to listen on turnouts IT2
      and IT5, the ActionListenOnBeans needs to be used.</p>

      <p>The ActionListenOnBeans can be placed anythere in the ConditionalNG tree, as long as it
      and its parents are enabled. If you disable this action, or any of its parent actions, the
      ActionListenOnBeans will not listen to its named beans.</p>

      <h3>Special actions</h3>

      <p>There are a couple of actions that is particular useful for this.</p>

      <p><strong>ActionFor</strong>
      </p>

      <p>ActionFor is a for-loop. It has four children.</p>

      <ul>
        <li><strong>Init</strong> - this action is first executed once. It's used to initialize the
        loop, for example setting a Memory to a particular value.</li>

        <li><strong>Condition</strong> - this expression decides if the loop should run one lap
        more. The loop will continue to run until this condition will be
        <strong>false</strong>.</li>

        <li><strong>Next</strong> - this action is executed at the end of the loop. It can for
        example be used to increment a counter in a Memory.</li>

        <li><strong>Action</strong> - this action is executed in each loop. It does the main
        work.</li>
      </ul>

      <p>Then ActionFor is executed, the Init action is run once. After that, the Condition
      expression is evaluated. If the condition returns <strong>true</strong>, the Action action is
      executed and at last the Next action is executed. Then the process is repeated, except that
      the Init action is only executed once.</p>

      <p><strong>ActionForEach</strong>
      </p>

      <p>ActionForEach is a for-loop.</p>

      <p>This action has a list of items. Either a constant list, or it can use a NamedBeanMap.</p>

      <p>The ActionForEach action loops through the list. It takes the first item in the list, assigns
      it to a Memory, and then executes its child action. Then it takes the second item in the
      list, assigns it to the Memory, and executes the child action.</p>
      <a id="digital_actions"></a>

      <h2>List of digital actions</h2>
      <p>This section lists all the digital actions that is currently available with LogixNG.</p>

      <p>Digital actions do something. Example: Set sensor IS2 to ON. Throw turnout LT52.</p>

      <p>Digital actions have system names with the letters <strong>DA</strong> (for
      <strong>D</strong>igital <strong>A</strong>ction). Example: IQDA002 or IQDA:0053. System
      names with colon are auto generated system names.</p>

      <p style="color:red">Items in red may need rethink or removal. I have ideas, but not always
      sure if these ideas are worth keeping. /Daniel</p>

      <p style="color:blue">Items in blue is not up-to-date with documentation. The documentation
      tells how they should work, but the code is not finished yet. /Daniel</p>

      <ul>
        <li>
          <p><strong>Light</strong>
          </p>

          <p>The Light action sets a light.</p>
        </li>

        <li>
          <p><strong>Sensor</strong>
          </p>

          <p>The Sensor action sets a sensor.</p>
        </li>

        <li>
          <p><strong>Turnout</strong>
          </p>

          <p>The Turnout action sets a turnout.</p>
        </li>

        <li>
          <p><strong>Throttle</strong>
          </p>

          <p>The Throttle action controls a throttle. It has child expressions for loco address,
          loco speed and loco direction. For now, an analog memory expression or an analog constant
          expression can be used to control the loco address and the loco speed, but once JMRI has
          support for AnalogIO devices, an AnalogIO may be used to control loco address and/or loco
          speed.</p>
        </li>

        <li>
          <p><strong>Timer</strong>
          </p>

          <p>The Timer action executes a child action after some time.</p>
        </li>

        <li>
          <p><strong>DoAnalogAction</strong>
          </p>

          <p>The DoAnalogAction reads an analog child expression and executes an analog child
          action.</p>
        </li>

        <li>
          <p><strong>DoStringAction</strong>
          </p>

          <p>The DoStringAction reads a string child expression and executes a string child
          action.</p>
        </li>

        <li>
          <p><strong style="color:red">HoldAnything</strong>
          </p>

          <p style="color:red">Remove this</p>

          <p>The HoldAnything can hold any type of action or expression.</p>
        </li>

        <li>
          <p><strong>IfThenElse</strong>
          </p>

          <p>The IfThenElse reads a digital child expression and if the answer is
          <strong>true</strong> it executes the <strong>then</strong> child action, else it
          executes the <strong>else</strong> child action.</p>
        </li>

        <li>
          <p><strong>Logix</strong>
          </p>

          <p>The Logix action reads a digital child expression and then executes boolean actions.
          Each boolean action takes the result from the expression and takes action accordingly.
          The recommended child boolean actions for this action is the OnChange action. The Logix
          action, together with the OnChange child boolean actions, acts like the JMRI Logix, with
          explains the name of this action.</p>
        </li>

        <li>
          <p><strong>Many</strong>
          </p>

          <p>The Many action executes many child actions.</p>
        </li>

        <li>
          <p><strong>ShutdownComputer</strong>
          </p>

          <p>The ShutdownComputer action either shutdown or restarts the computer. This action is
          mainly included to demonstrate the possibilities of LogixNG, but it may be useful in some
          cases, for example when a Raspberry Pi computer runs the layout and there is no keyboard
          and mouse connected to the Raspberry Pi computer. It's then possible to use a sensor to
          shut down the computer.</p>
        </li>
      </ul>
      <a id="digital_boolean_actions"></a>
      <h2>List of digital boolean actions</h2>

      <p>This section lists all the digital boolean actions that is currently available with
      LogixNG.</p>

      <p>Digital boolean actions takes a true/false value and do something. The most common use is
      the digital action Logix together with the digital boolean action OnChange.</p>

      <p>Digital boolean actions have system names with the letters <strong>DB</strong> (for
      <strong>D</strong>igital <strong>B</strong>oolean action). Example: IQDB002 or IQDB:0053.
      System names with colon are auto generated system names.</p>

      <p style="color:red">Items in red may need rethink or removal. I have ideas, but not always
      sure if these ideas are worth keeping. /Daniel</p>

      <p style="color:blue">Items in blue is not up-to-date with documentation. The documentation
      tells how they should work, but the code is not finished yet. /Daniel</p>

      <ul>
        <li>
          <p><strong>OnChange</strong>
          </p>

          <p>Executes a child action if the parameter is changed and to the desired value.</p>
        </li>
      </ul>
      <a id="digital_expressions"></a>
      <h2>List of digital expressions</h2>

      <p>This section lists all the digital expressions that is currently available with
      LogixNG.</p>

      <p>Digital expressions asks a question and gives a true/false answer. Example: Is sensor IS2
      on? Is turnout LT52 thrown?</p>

      <p>Digital expressions have system names with the letters <strong>DE</strong> (for
      <strong>D</strong>igital <strong>E</strong>xpression). Example: IQDE002 or IQDE:0053. System
      names with colon are auto generated system names.</p>

      <p style="color:red">Items in red may need rethink or removal. I have ideas, but not always
      sure if these ideas are worth keeping. /Daniel</p>

      <p style="color:blue">Items in blue is not up-to-date with documentation. The documentation
      tells how they should work, but the code is not finished yet. /Daniel</p>

      <ul>
        <li>
          <p><strong>And</strong>
          </p>

          <p>The And expression has a number of child expressions and answers <strong>true</strong>
          if and only if all the child expressions answer <strong>true</strong>. If any of the
          child expressions answers <strong>false</strong>, the <strong>And</strong> expression
          answers <strong>false</strong>.</p>
        </li>

        <li>
          <p><strong>Antecedent</strong>
          </p>

          <p>The Antecedent expression has a formula together with a number of child expressions.
          It evaluates the formula with the results from the child expressions. The Antecedent
          expression follows the same rules as in a Conditional in Logix. An Antecedent formula can
          have parentheses and the words <strong>AND</strong> and <strong>OR</strong> to build the
          formula.</p>
        </li>

        <li>
          <p><strong>Light</strong>
          </p>

          <p>The Light expression checks the state of a light and answers <strong>true</strong> if
          the light has the desired state.</p>
        </li>

        <li>
          <p><strong>Sensor</strong>
          </p>

          <p>The Sensor expression checks the state of a sensor and answers <strong>true</strong>
          if the sensor has the desired state.</p>
        </li>

        <li>
          <p><strong>Turnout</strong>
          </p>

          <p>The Turnout expression checks the state of a turnout and answers <strong>true</strong>
          if the turnout has the desired state.</p>
        </li>

        <li>
          <p><strong>False</strong>
          </p>

          <p>The False expression always answers <strong>false</strong>.</p>
        </li>

        <li>
          <p><strong>True</strong>
          </p>

          <p>The True expression always answers <strong>true</strong>.</p>
        </li>

        <li>
          <p><strong style="color:red">Hold</strong>
          </p>

          <p>The Hold expression has two child expressions, one trigger expression and one hold
          expression. For this expression to become <strong>true</strong>, both the trigger
          expression and the hold expression must answer <strong>true</strong>. But then it stays
          <strong>true</strong> as long as the hold expression stays <strong>true</strong>.</p>
        </li>

        <li>
          <p><strong>Or</strong>
          </p>

          <p>The Or expression has a number of child expressions and answers <strong>true</strong>
          at least one the child expressions answers <strong>true</strong>. If all of the child
          expressions answer <strong>false</strong>, the <strong>And</strong> expression answers
          <strong>false</strong>.</p>
        </li>

        <li>
          <p><strong>Not</strong>
          </p>

          <p><strong style="color:red">This expression does not exist yet. Implement it.</strong>
          </p>

          <p>The Not expression has one child expression and answers <strong>true</strong> if the
          child expression answer <strong>false</strong>, and <strong>false</strong> if the child
          expression answers <strong>true</strong>.</p>
        </li>

        <li>
          <p><strong style="color:blue">ResetOnTrue</strong>
          </p>

          <p><strong style="color:red">Update the code</strong>
          </p>

          <p>The ResetOnTrue expression has two child expressions, one primary expression and one
          secondary expression. When the primary expression becomes <strong>true</strong>, the
          secondary expression is reset. This expression is primary designed to be used with a
          timer expression as the secondary expression. The timer will then restart when it's
          reset.</p>

          <p>The user can select between four different ways on when this expression answers
          <strong>true</strong>.</p>

          <ul>
            <li>The primary expression trigger, and until the secondary expression becomes
            true.</li>

            <li>The primary expression trigger, and while the secondary expression is true.</li>

            <li>The primary expression stays true, and until the secondary expression becomes
            true.</li>

            <li>The primary expression stays true, and while the secondary expression is true.</li>
          </ul>

          <p>Example usages for this expression:</p>

          <ul>
            <li>Wait on a timer. For example, when turnout IT1 changes to Thrown, wait 5 seconds until
            expression becomes true.</li>

            <li>Wait on a timer. For example, when turnout IT1 changes to Thrown, let the expression be
            true for 5 seconds.</li>
          </ul>
        </li>

        <li>
          <p><strong>Timer</strong>
          </p>

          <p>The Timer expression waits some time before it resets.</p>
        </li>

        <li>
          <p><strong>TriggerOnce</strong>
          </p>

          <p>The TriggerOnce expression answers <strong>true</strong> one single time and then
          <strong>false</strong> until JMRI is restarted. It's designed to be used when something
          needs to be done exactly one time, for example set some turnouts to a specified inital
          state or to set some memories to some predefined values.</p>
        </li>
      </ul>
      <!--#include virtual="/Footer.shtml" -->
    </div>
    <!-- closes #mainContent-->
  </div>
  <!-- closes #mBody-->
  <script src="/js/main.js"></script>
</body>
</html>
