<html>
<head>
<title>LogixNG Tutorial</title>
<script type="text/javascript" src="/web/js/jquery-2.0.3.min.js"></script>
</head>

<body>
<table width="800">
<tr>
<td>


<h1>Notes - REMOVE THIS</h1>

LogixNG has four main building blocks. `Actions` that does something. `Expressions` that evaluates to something. `Female sockets` that something can be connected to. `Male sockets` that encapsulate an action or expression so that it can be connected to a female socket.

All actions, expressions and male sockets has a well defined type, for exampe the ExpressionTurnout evaluates the state of a turnout and returns true/false. And the AnalogExpressionConstant returns a constant value that is a floating point number.

But in some cases, the user might want to mix different types of expressions. The user might for example add a string to a number, 

<hr>

HandleDelayedAction

public Data ConditionalNG.getData(String className);

Ha en generell klass som hanterar delayed action för alla NamedBean.

<hr>

Tutorial

Note for developers

Hidden text. Man klickar på länken "Note for developers" och då visas denna paragraf.

<hr>

AAA = a+b
AAA = {a}
AAA = "Kalle"

<hr>

Sensor ska kunna hålla resultatet tills det läses av. Prova med timer på 10 sek.

<hr>



















<h1>LogixNG Tutorial</h1>

This tutorial has an <a href="logixngpreview.jmri.zip">example profile</a>.
<p>
This tutorial has a number of chapters, there each chapter demonstrates some feature of LogixNG. Each chapter has its
own ConditionalNG in the example profile, and this ConditionalNG has the end result of each chapter.
<p>
The sensors, turnouts, and so on, that's used in this tutorial has system names like IS_3_5, there the first number is
the chapter it's used in.
<p>
Some chapters has a panel and the panels has names like "Chapter 1", that tells which chapter this panel is used for.

<hr>

<p>

<a href="chapter0.html">Chapter 0 - Setting up the profile</a>
<p>
<a href="chapter1.html">Chapter 1 - A simple LogixNG</a>
<p>
<a href="chapter2.html">Chapter 2 - The clipboard</a>
<p>
<a href="chapter3.html">Chapter 3 - Basic actions and expressions</a>
<!-- <a href="chapter3.html">Chapter 3 - Initialization</a> -->
<p>
<a href="chapter4.html">Chapter 4 - Working with timers</a>
<p>
<a href="chapter5.html">Chapter 5 - Controlling an engine</a>
<p>
<a href="chapter6.html">Chapter 6 - Formula</a>
<p>
<a href="chapter7.html">Chapter 7 - Sequence - controlling a crane and a loco</a>
<p>
<a href="chapter8.html">Chapter 8 - Local variables</a>
<p>
<a href="chapter9.html">Chapter 9 - References</a>
<p>
<a href="chapter10.html">Chapter 10 - Tables</a>
<p>
<a href="chapter11.html">Chapter 11 - Modules</a>
<p>
<a href="chapter12.html">Chapter 12 - Scripts</a>
<p>
<a href="chapter13.html">Chapter 13 - Threads</a>
<p>
<a href="chapter14.html">Chapter 14 - The debugger</a>
<p>


<hr>
<hr>
<hr>



<h2>Error handling</h2>

<h3>Throw</h3>

Throw causes errors to be thrown to the upper level. It's useful if you want an error to abort execution for some
levels. If you, for example, has a for loop, and you want that loop to be aborted if an error occurs in it's
child, you can let the children throw the error.

<hr>


<h2>Threads</h2>

The ConditionalNGs run in a separate thread from the rest of JMRI. But it's possible to use several threads for
LogixNG, to let some ConditionalNGs run on one thread and other ConditionalNGs run on another thread. You might have
one ConditionalNG that is slow and other ConditionalNGs that needs to respond quickly. It could then be useful to move
the slow ConditionalNG to a different thread.
<p>
Note that if a ConditionalNG is too slow, it will be difficult to edit that ConditionalNG since the editor needs to
wait on the ConditionalNG to finish execution before the editor can update it.
<p>
If you want to move a ConditionalNG from one thread to another, you need to restart JMRI for the change to take effect.
<p>
The main reason to use different threads for different ConditionalNGs is the debugger (se chapter 14). When you debug a
ConditionalNG step by step, the debugger stops the thread that the ConditionalNG is running on. If there are other
ConditionalNGs running on the same thread, those are stopped as well. Therefore it's often useful to move the
ConditionalNG that you want to debug to its own thread before you start debugging it. To simplify this, there is an
extra thread, called the debug thread, that you can use for this purpose. But every thread might be used for debugging.


<hr>


<h2>The debugger</h2>

Creating computer programs is an art. Good development tools help, but things doesn't always work as you expect. And
LogixNG is no exception. Sometimes, the rules you set up doesn't work. To help with this, LogixNG has a debugger.

<h3>Debug step by step</h3>

<h3>Adding break points</h3>

<h3>Watch items</h3>

Currently, the following items can be watched:

<ul>
<li>Local variables</li>
<li>Memories</li>
<li>Turnouts</li>
<li>...</li>
</ul>

<h3>For JMRI developers: How does the debugger works internally?</h3>




<hr>


<h2>Replay a ConditionalNG</h2>

There are situations when the debugger is not enough. You might run the layout on a Raspberry Pi at the local model
railroad club and you may want to debug the layout at your home using your Windows computer. You can do that, by
activate logging of the session at the club, and then replay that session at home.

<p>

Replay



<h3>Logging of the layout</h3>


<h3>Notes for the JMRI developers: The male socket stack</h3>

LogixNG is designed to be modular and flexible with small classes with well defined purposes.

<ol>
<li>Standard male socket - manages the actions and expressions</li>
<li>Replay male socket - Replay a previous logged session</li>
<li>Debug male socket - Debug a session. Handle step by step debugging and breakpoints.</li>
</ol>


<hr>
<hr>
<hr>


<h2>Notes for developers</h2>

The rest of the chapters are aimed at developers of JMRI. These chapters explains the internals of LogixNG and how to
use LogixNG from other parts of JMRI.

<p>

<a href="chapter13.html">Chapter 13 - Adding a new action or expression</a>
<p>
<a href="chapter14.html">Chapter 14 - The future of LogixNG - Expanding it further</a>
<p>
<a href="chapter15.html">Chapter 15 - Using LogixNG in other parts of JMRI or by third party software</a>
If you are developing some tool, for example something similat to SSL or SSM, and you want to use LogixNG as the
engine, there are some things that's good to know.
<p>
LogixNG has a reserved group of system names for items created by other parts of JMRI. IQDA:JMRI:aaaa. The purpose of
these special system names is to guarantee that there will never be any collission between JMRI system names and system
names created by the user.
<p>
LogixNG has a reserved group of system names for items created by third party software that uses JMRI as a library.
IQDA:JMRI-LIB:aaaa. The purpose of
these special system names is to guarantee that there will never be any collission between the third party software
system names and system names created by the user or by JMRI.
<p>
The user can, but should not, create their own system names using IQDA:JMRI:aaaa or IQDA:JMRI-LIB:aaaa system names. By
doing so, the user takes the risk of collissions with JMRI or third party software. But for developers, this may be
useful during development.
<p>
While developing a tool for JMRI, you may end up with the need to create some special action or expression for LogixNG
to be used only in your tool. You can do that by developing the tool, but not announce its existence. LogixNG will
still be happy to use the new action or expression, but the user will not be able to add that action or expression
anywhere else in his ConditionalNGs. Note that people may argue about whenether this is good or bad, but it's at least
possible.


<p>
<a href="chapter99.html">Chapter 99 - Note to reviewers of JMRI. When to merge LogixNG?</a>
<p>



<p>

Menu choice "Tools / Tables / LogixNG" has a sub menu with three tables:
<ul>
<li>LogixNG</li>
<li>LogixNG Modules</li>
<li>LogixNG Tables</li>
</ul>

Select "Tools / Tables / LogixNG / LogixNG" to open the table with the LogixNGs. The other two tables,
"LogixNG Modules" and "LogixNG Tables", are described later in this tutorial.
<p>
On the "Meny" column, select "Edit" for the "Tutorial LogixNG". This brings up a table of ConditionalNGs that are
owned by this LogixNG. Each ConditionalNG in this tutorial has a user name starting with a number and a short
description. These user names are used as headers in this tutorial and demonstrates different things in LogixNG.

<hr>

<h2>1. Basics</h2>

Create a LogixNG
Create a ConditionalNG

Create an action: ActionTurnout

Remove the action and add the action IfThenElse.
Add ExpressionSensor and ActionTurnout

Lets add a new IfThenAction with a ExpressionSensor and a ActionTurnout. To do this, we need to add the action
Many. We can do this by cutting the IfThenElse expression so it's moved to the clip board, then add the Many
action and then paste the IfThenElse action back.




<hr>

<h2>00. Trigger once</h2>

Something may need to be done once to initialize things. For this purpose, there is the TriggerOnce expression
that returns true once and never more. This expression can be used to initialize things.




<hr>

<h2>10. Working with timers</h2>



<p>
Logix has a feature there a turnout or a sensor can be set delayed. This feature is not yet implemented in
LogixNG, except that you can use timers to do this in LogixNG. The reason for this not beeing implemented yet is
that I'm not sure how to implement this the best way. It's definitely possible to implement this the same way as
in Logix, but since LogixNG works somewhat different, it may be better to implement it different in LogixNG than
in Logix.



<p>
When the IS_10_1 sensor is active, the timer is started/reset. But as long as this sensor is active, the timer is
hold in the start condition. What if we want the sensor to only trigger a start, instead of holding it in the start
condition? We can do that by using the "Trigger Once" expression. It returns true the first time its child
expression returns true, but when returns false until its child expression has returned false.



<hr>

<h2>11. Controlling an engine</h2>

An exhibition has a model railroad that children can run. An adult presses a button and then a child can control
the layout by using a potentiometer and a switch for controlling the speed and direction of the engine. After five
minutes, the layout stops and the next child in queue will get to run the layout. The adult presses the button and
the layout works for five more minutes.

<p>
<ul>
<li>Sensor IS1 - The button the adult presses to run the layout.</li>
<li>Memory IM1 - For this example, we use a memory, but in real world we would use an AnalogIO, for example a
Meter.</li>
<li>Sensor IS2 - Sensor for controlling the direction of the engine.</li>
<li>Memory IM2 - The loco address.</li>
<li>Memory IM3 - Flag if the layout is running or not.</li>
</ul>

We use an ActionTimer to let the child run the layout for five minutes.
We use an ActionThrottle to control the engine.





<hr>

<h2>15. Using sequence ?????</h2>

Controlling a crane and an engine.




<hr>

<h2>16. Using Formula</h2>

a == b, a != b, a < b, a <= b, a > b, a >= b
a + b, a - b, ....
(a)


<h3>Functions</h3>

For now, there is only a few functions implemented in LogixNG. But it's easy to add more functions.

The existing functions are:

sin(x)
sin(x,y,...)

How to add a new function?

Adding the function fibonnaci ???

Adding the function loconetSlots




<hr>

<h2>20. Using references and tables</h2>






<hr>

<h2>30. Using modules</h2>


Calculate the Fibonnaci ???? numbers.






<hr>

<h2>90. Local variables and scripts</h2>

A script can use local variables. But local variables only exists during the execution of the action/expression
that defines the local variable. This ConditionalNG uses the same script in three different cases, there the local
variable is a number, a string or does not exist at all.
<p>
The script is in the file AAAAAA.AA. It's loaded by the ExpressionScript expression.






<p>
Select "Edit" for a ConditionalNG to open the ConditionalNG editor.
<p>
A ConditionalNG is a tree of actions and expressions, there some actions and some expressions can have children.
<p>
The editor doesn't know anything about actions nor expressions. Instead, the editor knows about female sockets and
male sockets. The female sockets is the exclamation marks and the question marks, followed by a name, for example "A4".
The name can be any number of letters and digits, starting with a letter.
<p>
The user never sees the male sockets, but each action and expression is encapsulated in a male socket.
<p>
Each ConditionalNG may have a memo there the user may enter some text, for example a description of the ConditionalNG.
Each ConditionalNGs in the example profile has a memo that describes that ConditionalNG.
<p>


<hr>

<h2>99. Adding a new action/expression</h2>

See the package <i>jmri.jmrix.loconet.logixng</i> for the classes mentioned in this part.
<p>
How do we add a new action or expression type to LogixNG? Lets assume we want to have an expression that looks at the
LocoNet slot manager and returns true if more that 75% of the slots are not free, false otherwise.
<p>
The first thing to notice is that is expression is LocoNet specific. Which means that it should be in a sub package to
jmri.jmrix.loconet and that the expression should not be available if there is no LocoNet connection. This is easy to
do. LogixNG uses @ServiceProvider to get a list of the available actions and expressions. For example, the class
jmri.jmrit.logixng.expressions.DigitalFactory provides a list of digital expressions. We can add our own factory class
for our LocoNet expression and we can make the method <i>getExpressionClasses()</i> conditional so that it only returns
our class if there is a LocoNet connection active.
<p>
Second, it may be helpful for the user if the LocoNet actions/expressions have their own category. So lets create that.
LogixNG has an "enum" Category, but since Java enums cannot be extended, the LogixNG Category class simulates an enum
without being a true enum class. We add the LocoNet category to the Factory class and let a static initializer in the
Factory class register the LocoNet category.
<p>
Now it's time to create the expression itself. For that, we need three classes. ExpressionSlotUsage that has the
expression itself, ExpressionSlotUsageXml that stores the expression to the panel xml file and ExpressionSlotUsageSwing
that has the swing editor for this expression.
<p>
For the expression itself, ExpressionSlotUsage, there is two important things to do. First, the expression needs to do
something useful, in this case check the slots in the slot manager. The interface jmri.jmrit.logixng.DigitalExpression
defines a digital expression and what it needs to do. It has a method <i>evaluate()</i> that returns a boolean. We need
to implement this method and it's here that we check the slots in the slot manager.
<p>
The second important thing we need to do in ExpressionSlotUsage is to register and unregister any listeners. In this
case, we want to listen for changed slots so we use the methods <i>registerListenersForThisClass()</i> and
<i>unregisterListenersForThisClass()</i> to register/unregister the listeners. Please check that listeners are not
registered twice. We do that by the varable <i>_listenersAreRegistered</i> to check if listeners has already been
registered.
<p>
The swing editor ExpressionSlotUsageSwing implements the <i>SwingConfiguratorInterface</i> that is used by the
ConditionalNG editor to create and edit actions and expressions. It does that by calling the method getConfigPanel()
in the SwingConfiguratorInterface that creates a JPanel with the components that are needed to configure the
action/expression. After the user has clicked "OK" to create a new expression or to save the changes, the method
validate() is called. If it returns true, a new object is created by a call to createNewObject() or the changes are
saved to the expresion by a call to updateObject().
<p>
In the case of ExpressionSlotUsageSwing, we have a sentense like "The number of slots which 'has not' state 'COMMON or
IDLE' is 'less than' '32', there the parts within '' are JComponents that let the user select different things. But
this sentence needs to be translated to different languages and the order of words may be different in another language.
The SwingConfiguratorInterface has a method parseMessage() that takes the message that we get from the bundle, together
with the array of JComponents, and then returns a new list of JComponents there the message has been replaced by JLabel
components and there the JComponents has been ordered according to the language.





<hr>

<h2>The future of LogixNG - Expanding it further.</h2>

The code in this section is in the package jmri.jmrit.logixng.future. To use these these actions and expressions, you
need to enable "Demo examples" in the LogixNG preferences. <u>These examples are only skeletons</u> that doesn't do
anything useful, except explaining the inner details of LogixNG.
<p>
Note that the actions and expressions in this example is disabled by default. In order to use them, go to menu Edit /
Preferences / LogixNG and select "Enable demo actions and expressions". If you have loaded the example panel file and
then have stored it again without enable demo, these actions and expressions will not be stored in the panel file. If
so, enable demo actions and expressions in the preferences and then go back to the original panel file which has these
actions and expressions.
<p>
Lets assume that a scientist wants to use JMRI and LogixNG to experiment with articifial intelligence on a model
railroad. He has a camera and a small image processing computer inside the engines that takes images and try to figure
out if there is a signal or a sign next to the track and if it finds one, it sends that image to the computer running
JMRI.
<p>
First we need to decide on what data we will work on. For this example, we want some image and a position.

<pre>
public interface AI_Image {

    // Get the address of the loco that sends the image
    public int getLocoAddress();

    // Set the address of the loco that sends the image
    public void setLocoAddress(int locoAddress);

    // Get the image
    public Image getImage();

    // Set the image
    public void setImage(Image image);

    // Get the position
    public Position getPosition();

    // Set the position
    public void setPosition(Position position);

}
</pre>
<p>
Note that local variables, memories and tables work with Java Object so you can store an <i>AI_Image</i> into these.
<p>
Then we need to decide what we want to do with this. Lets assume we want expressions that gets an AI_Image, for
example an expression that fetches the image from a particular enigne. And that we want actions that can take an
AI_Image and do something, for example do some image processing on it or to check if it's a signal and then take
action like stopping the engine. So we create interfaces for AI_Image expression and AI_Image action.
<pre>
public interface AI_ImageExpression extends Base {
    
    public AI_Image evaluate() throws JmriException;
    
}
</pre>

<pre>
public interface AI_ImageAction extends Base {
    
    public void doSomething(AI_Image image) throws JmriException;
    
}
</pre>

These interfaces implements the <i>jmri.jmrit.logixng.Base</i> interface. It has some methods that are common to all
actions/expressions in LogixNG, for example methods for getting the parent, finding the root of the tree, getting
the number of children and getting a particular child.
<p>
The managers works on items that are NamedBeans so we also needs an interface that extends NamedBean. The reason that
the AI_ImageExpression and AI_ImageAction does not implement NamedBeans is that the female sockets should not be
NamedBeans and that the female socket needs to implement the interface it is socket for. So instead, we create
additional interfaces, AI_ImageExpressionBean and AI_ImageActionBean that extends both the action/expression and
NamedBean.
<pre>
public interface AI_ImageExpressionBean extends NamedBean, AI_ImageExpression {
}
</pre>

<pre>
public interface AI_ImageActionBean extends NamedBean, AI_ImageAction {
}
</pre>

After that, we need to create the male and female sockets. A male socket wraps the actions/expressions so that it
can be connected to a female socket. And a female socket allowes an action/expression to be connected to something
else.

<p>

Then we need to create the managers for the actions and expressions.



<p>

The actions and expressions:

Actions
Many
IfImageIsSignal - Do something if the image shows a signal with aspect green.
IfImageIsSign - Do something if the image shows a sign with a speed limit.

Expressions
GetImageFromLoco - Read the last image from loco NN.




</td>
</tr>
</table>
</body>
</html>
