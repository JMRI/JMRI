  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">


<html lang="fr">
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 15.17), see www.w3.org">

  <title>JMRI: Patterns and Structure</title>
  <meta content="Bob Jacobsen" name="Author">
  <meta name="keywords" content=
  "JMRI technical code patterns structure">
  <!-- The combination of "Define" and {Header,Style, Logo and Footer} comments -->
  <!-- are an arbitrary design pattern used by the update.pl script to -->
  <!-- easily replace the common header/footer code for all the web pages -->
  <!-- delete the following 2 Defines if you want to use the default JMRI logo -->
  <!-- or change them to reflect your alternative logo -->
  <!-- Style -->
  <meta http-equiv="content-type" content=
  "text/html; charset=iso-8859-1">
  <link rel="stylesheet" type="text/css" href="/css/default.css"
  media="screen">
  <link rel="stylesheet" type="text/css" href="/css/print.css"
  media="print">
  <link rel="icon" href="/images/jmri.ico" type="image/png">
  <link rel="home" title="Home" href="/">
<!-- /Style -->


<!--#include virtual="/Header" -->
<!--#include virtual="Sidebar" -->

	<div id="mainContent">
	    <!-- -------- -->
	    <!--  Teaser  --> <!-- Optional -->
	    <!-- -------- -->

<H1>JMRI: Mod&#232;les et Organisation</H1>
<p>
JMRI a grandi et &#233;volu&#233; avec le temps, et
vous ne pouvez pas toujours voir les structures et les 
caract&#233;ristiques actuellement pr&#233;f&#233;r&#233;es
en regardant des morceaux de l'ancien code.
<p>
Cette page tente de d&#233;crire la structure et les mod&#232;les recommand&#233;s,
et fournir des exemples des meilleures pratiques actuelles.

<a id="namedbeans" name="namedbeans"></a><h2>Noms, NamedBeans, et les gestionnaires</h2>

Le concept "NameBean" est la base de JMRI.
Un <a href="http://jmri.org/JavaDoc/doc/jmri/NamedBean.html">NamedBean</a>
est un objet de base qui repr&#233;sente quelque chose, typiquement quelque chose 
comme un Capteur ou un Aiguillage.
<ul>
<li>Ils sont appel&#233;s "Bean" parce qu'ils sont une unit&#233; 
d'interaction: De multiples morceaux de code peuvent travailler avec l'un d'eux, il peut &#234;tre charg&#233; ou stock&#233;, etc.
<li>Ils sont "named" parce que pour &#234;tre s&#251;r qu'ils sont uniques et retrouvables: Il y a seulement un Aiguillage NamedBean
appel&#233; LT01, et il repr&#233;sente un objet sp&#233;cifique du r&#233;seau adress&#233;( named ).
Voir la  <a href="Names.shtml">page sur les Noms</a> pour en savoir davantage.
</ul>
Fonctionnellement, toutes les classes d'objets du syst&#232;me ( Capteur, Aiguillage,... ) et
leurs mise en oeuvre sp&#233;cifiques ( LnSensor,  XNetTurnout, ...), h&#233;rite de la classe de base
<a href="http://jmri.org/JavaDoc/doc/jmri/NamedBean.html">NamedBean</a>.
<p>
Pour obtenir l'acc&#232;s &#224; un objet sp&#233;cifique (un NamedBean d'un type sp&#233;cifique avec un nom sp&#233;cifique ), vous faites 
des demandes &#224; un gestionnaire: vous demandez un
<a href="http://jmri.org/JavaDoc/doc/jmri/TurnoutManager.html">TurnoutManager</a> pour un Aiguillage sp&#233;cifique
&#224; votre tour, vous
<a href="IntroStructure.shtml">acc&#233;dez aux gestionnaires &#224; travers l'InstanceManager commun</a>.

<p>
Un utilisateur peut vouloir r&#233;&#233;f&#233;rencer un NamedBean via un nom utilisateur, et &#224; son tour peut vouloir
changer le NetBean sp&#233;cifique auquel le nom utilisateur se r&#233;f&#232;re. "Yard East Turnout" peut &#234;tre 
"LT12" &#224; un point et plus tardpeut changer en "CT5". Pour g&#233;rer ceci,
votre code utilise les objets
<a href="http://jmri.org/JavaDoc/doc/jmri/NamedBeanHandle.html">NamedBeanHandle</a>
pour g&#233;rer les r&#233;f&#233;rences pour NamedBeans. Ils automatisent le processus de renommage.

  <p>Pour ce faire, lorsque vous souhaitez stocker une r&#233;f&#233;rence &#224; 
      NamedBean, par exemple pour se souvenir d'un capteur particulier, d'un aiguillage, d'un m&#226;t de signalisation, etc.
      demander (par l'interm&#233;diaire de l'InstanceManager) au NamedBeanHandlerManager de vous donner un 
      NamedBeanHandle :
      <pre><code>
      NamedBeanHandle&lt;Sensor&gt; handle = InstanceManager.getDefault(NamedBeanHandleManager.class).getNamedBeanHandle(name, sensor) ;
      </code></pre> 
      o&#249; <code>nom</code> est le nom de la cha&#238;ne que l'utilisateur a fourni, soit un 
      nom du syst&#232;me ou nom d'utilisateur, et <code>capteur</code> est l'objet particulier <code>capteur</code>.
      en cours de stockage.   Lorsque vous avez besoin de r&#233;f&#233;rencer le capteur lui-m&#234;me, il suffit de faire
      <pre><code>
      capteur = handle.getBean() ;
      </code></pre>
      Veuillez utiliser <code>getBean()</code> chaque fois que vous devez acc&#233;der &#224; Bean.  Ne mettez pas en cache la
      r&#233;f&#233;rence de <code>getBean()</code>.  De cette fa&#231;on, si quelqu'un effectue une op&#233;ration de "d&#233;placement" ou de "renommage",
      le <code>NamedBeanHandle</code> sera mis &#224; jour et votre prochain appel <code>getBean()</code> obtiendra la
      bonne r&#233;f&#233;rence.

      <h3>Propri&#233;t&#233;s de Bean</h3>

      <p>les NamedBeans ont g&#233;n&#233;ralement un &#233;tat, par exemple un <code>Capteur</code> peut
      &#234;tre actif ou inactif (ou inconnu ou incoh&#233;rent). Cet &#233;tat est
      repr&#233;sent&#233; par une ou plusieurs propri&#233;t&#233;s du Java Bean. Code en Java et Jython
      peut utiliser le
      <a href="https://docs.oracle.com/javase/tutorial/uiswing/events/propertychangelistener.html">PropertyChangeListener
      pattern</a> pour &#234;tre averti lorsqu'une propri&#233;t&#233; donn&#233;e change. A titre d'exemple,
      lorsqu'un aiguillage est configur&#233; avec un capteur de r&#233;troaction,
      l'objet <code>Turnout</code> s'enregistre en tant qu'auditeur de changement
      lorsque la propri&#233;t&#233; d'&#233;tat du <code>Sensor</code> change, et met &#224; jour
      la <code>Turnout</code>'s <code> "KnownState"</code> propri&#233;t&#233;.</p>

      <p>Les propri&#233;t&#233;s disponibles de Bean sont d&#233;finies dans la classe de base abstraite
      g&#233;n&#233;ralement, par exemple <code>AbstractTurnout</code>
      d&#233;finit <code> "CommandedState"</code>,
      <code> "KnownState"</code>, <code> "feedbackchange"</code>, <code> "locked"</code>
      et d'autres encore au moment de la r&#233;daction du pr&#233;sent document. Ces propri&#233;t&#233;s ne sont pas
      d&#233;pendant du syst&#232;me. Certaines des propri&#233;t&#233;s sont uniquement d'ex&#233;cution (par exemple, l'&#233;tat --
      ), tandis que d'autres (par exemple, le retour d'information sur l'aiguillage
      ) sont des param&#232;tres de configuration, s&#233;lectionn&#233;s par l'utilisateur et enregistr&#233;s entre
      sessions.</p>

      <h3>Edition et sauvegarde des NamedBeans</h3>

      <p>Les NamedBeans sont cr&#233;&#233;s et configur&#233;s par l'utilisateur &#224; l'aide d'actions. 
      La majeure partie de l'UI pour ces actions se trouve dans
      le <a href="https://jmri.org/JavaDoc/doc/jmri/jmrit/beantable/package-summary.html">jmri.jmrit.beantable</a>
      en utilisant le tableau g&#233;n&#233;rique <code>BeanTable{Frame,Pane,Model}</code>
      des classew sp&#233;cialis&#233;es pour le type particulier, par exemple dans la
      <a href="https://jmri.org/JavaDoc/doc/jmri/jmrit/beantable/TurnoutTableAction.html"><code>TurnoutTableauAction</code></a>
      classe. Les options de configuration pr&#233;sentes dans le tableau et le dialogue d'&#233;dition
      sont sp&#233;cifiques au type (<code>Turnout</code>) mais pas au syst&#232;me.</p>
      
      <p>Les Beans avec les options configur&#233;es sont persistant dans le
      Fichier XML de configuration (et de panel) lorsque l'utilisateur les enregistre. 
      La persistance est g&#233;r&#233;e par le syst&#232;me et l'objet sp&#233;cifique ManagerXml
      classe, par
      exemple <a href="https://jmri.org/JavaDoc/doc/jmri/jmrix/loconet/configurexml/LnTurnoutManagerXml.html">LnTurnoutManagerXml</a>
      ou <a href="https://jmri.org/JavaDoc/doc/jmri/jmrix/openlcb/configurexml/OlcbTurnoutManagerXml.html">OlcbTurnoutManagerXml</a>,
      qui s'appuient fortement sur un code partag&#233;
      dans <a href="https://jmri.org/JavaDoc/doc/jmri/managers/configurexml/AbstractTurnoutManagerConfigXML.html">AbstractTurnoutManagerConfigXML</a>,
      mais peut introduire des fonctionnalit&#233;s sp&#233;cifiques au syst&#232;me et collaborer avec
      le gestionnaire sp&#233;cifique au syst&#232;me et &#224; l'objet
      (par exemple <a href="https://jmri.org/JavaDoc/doc/jmri/jmrix/openlcb/OlcbTurnoutManager.html">OlcbTurnoutManager</a>)
      pour y parvenir.</p>

      <p>La classe de base g&#232;re la persistance des param&#232;tres utilisateur qui ont &#233;t&#233; saisis
      via la BeanTable.</p>

      <h3>Propri&#233;t&#233;s sp&#233;cifiques au syst&#232;me</h3>
      
      <p>Ajouter une propri&#233;t&#233; sp&#233;cifique au syst&#232;me n&#233;cessite l'utilisation d'une API g&#233;n&#233;rique,
      parce que le code dans le paquet  <code>jmrit.beantable</code>
       <a href="IntroStructure.shtml">ne peut pas d&#233;pendre</a> des 
      jmrix.system-specific packages. Tous les NamedBeans ont
      un <a href="https://jmri.org/JavaDoc/doc/jmri/NamedBean.html#setProperty-java.lang.String-java.lang.Object-">setProperty</a>
      et <a href="https://jmri.org/JavaDoc/doc/jmri/NamedBean.html#getProperty-java.lang.String-">getProperty</a>
      o&#249; des valeurs arbitraires peuvent &#234;tre enregistr&#233;es pour n'importe quelle cl&#233; de cha&#238;ne. Ces 
      propri&#233;t&#233;s sont persistantes dans le fichier XML par la classe de base de
      ManagerXml, donc aucun code n'a besoin d'&#234;tre &#233;crit pour lui. Une vari&#233;t&#233; de
      types peut &#234;tre choisi pour la valeur de la propri&#233;t&#233;, tels que <code>Integer</code>
      ou <code>Boolean</code>, et sera correctement persistant et r&#233;cup&#233;r&#233;
      lors du chargement. Les types personnalis&#233;s peuvent fonctionner s'ils ont un <code>toString()</code>
      et un constructeur qui ne prend qu'une <code>String</code> comme argument
      et ceux-ci s&#233;rialisent et analysent correctement la valeur de la donn&#233;e.</p>

      <p> Pour permettre &#224; l'utilisateur de modifier ces propri&#233;t&#233;s sp&#233;cifiques au syst&#232;me, un
      <code>Manager</code> peut d&#233;clarer l'ensemble des propri&#233;t&#233;s prises en charge en retournant 
      le formulaire dûment rempli
      <a href="https://jmri.org/JavaDoc/doc/jmri/NamedBeanPropertyDescriptor.html">NamedBeanPropertyDescriptor</a>
      objets de
      la <a href="https://jmri.org/JavaDoc/doc/jmri/Manager.html#getKnownBeanProperties--">getKnownBeanProperties</a>
      m&#233;thode. Ce descripteur indique &#224; la BeanTable que des colonnes suppl&#233;mentaires doivent
      &#234;tre cr&#233;&#233;es, le type de donn&#233;es que ces colonnes contiendront et ce qui devrait
      &#234;tre les noms des colonnes (imprim&#233;s dans l'en-t&#234;te). Les colonnes sp&#233;cifiques au syst&#232;me
      sont cach&#233;s par d&#233;faut &#224; l'utilisateur ; l'utilisateur doit cliquer sur une case &#224; cocher
      dans la ligne inf&#233;rieure pour les afficher ; la case &#224; cocher n'appara&#238;t que s'il y a
      des propri&#233;t&#233;s sp&#233;cifiques au syst&#232;me. Le nom de la colonne doit &#234;tre rempli avec un
      cha&#238;ne localis&#233;e qui devrait sortir du
      <code>Manager</code>'s <code>Bundle</code>.</p>

      <a id="SPI" name="SPI"></a>
      <h2>Fournisseurs de services</h2>
      Java fournit une ressource, en utilisant une "interface de fournisseur de services",
      qui nous permet de r&#233;duire la complexit&#233; de notre code en faisant en sorte que le code 
      lui-m&#234;me d&#233;couvre les &#233;l&#233;ments disponibles et &#224; installer.<br>
      Pour en savoir plus, consultez les sections sur les tutoriels
      "<a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html">Cr&#233;ation d'applications extensibles</a>"
      et
      "<a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html">Introduction aux interfaces des fournisseurs de services</a>".
      
      <p>
      Par exemple, en annotant une classe avec
      <pre><code>
      @Fournisseur de services (service = PreferencesManager.class)
      </code></pre> 
      le syst&#232;me de pr&#233;f&#233;rences JMRI
      d&#233;couvrira automatiquement que la classe utilise les pr&#233;f&#233;rences
      et devrait &#234;tre connect&#233;e.  Cela signifie que nous n'avons pas &#224; 
      modifier les classes de pr&#233;f&#233;rences pour rechercher chaque nouvelle classe &#224; l'aide de celles-ci, 
      et que nous pouvons (&#233;ventuellement) construire et distribuer plus progressivement JMRI.
      
      <p>
      Les mod&#232;les disponibles (les liens sont vers le JavaDoc de l'interface ou de la classe 
      en pr&#233;cisant la fonctionnalit&#233;) :
      <dl>
      <dt><a href="https://jmri.org/JavaDoc/doc/jmri/server/web/spi/WebManifest.html">ConnectionTypeList</a><</dt>
      <dt><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServlet.html">HttpServlet</a><</dt>
        <dd>(Notez que c'est une classe d&#233;finie par Java, pas une interface d&#233;finie par JMRI)</dd>
      <dt><a href="https://jmri.org/JavaDoc/doc/jmri/InstanceInitializer.html">InstanceInitializer</a><</dt>
        <dd>Fournit un moyen pour l JMRI InstanceManager de cr&#233;er une instance de la classe lorsqu'une demande est faite</dd>
      <dt><a href="https://jmri.org/JavaDoc/doc/jmri/spi/JsonServiceFactory.html">JsonServiceFactory</a><</dt>
      <dt><a href="https://jmri.org/JavaDoc/doc/jmri/spi/PreferencesManager.html">PreferencesManager</a></dt>
      <dt><a href="https://jmri.org/JavaDoc/doc/jmri/swing/PreferencesPanel.html">Panel des pr&#233;f&#233;rences</a></dt>
      <dt><a href="https://jmri.org/JavaDoc/doc/jmri/jmrit/beantable/signalmast/SignalMastAddPane.html">SignalMastAddPane</a><</dt>
        <dd>Fournir un panneau sp&#233;cifique au type utilis&#233; pour ajouter/modifier les informations dans un objet concret SignalMast</dd>
      <dt><a href="https://jmri.org/JavaDoc/doc/apps/startup/StartupActionFactory.html">StartupActionFactory</a></dt>
      <dt><a href="https://jmri.org/JavaDoc/doc/apps/startup/StartupModelFactory.html">StartupModelFactory</a></dt>
      <dt><a href="https://jmri.org/JavaDoc/doc/jmri/server/web/spi/WebManifest.html">WebManifest</a></dt>
      <dt><a href="https://jmri.org/JavaDoc/doc/jmri/server/web/spi/WebServerConfiguration.html">Configuration du serveur web</a></dt>
      </dl>

      <p>
      Les classes qui fournissent le SPI doivent &#233;galement &#234;tre enregistr&#233;es dans le syst&#232;me pour pouvoir &#234;tre retrouv&#233;es.
      JMRI le fait avec des entr&#233;es
      dans les fichiers du r&#233;pertoire <code>target/classes/META-INF/services/</code>.
      Ces entr&#233;es sont cr&#233;&#233;es automatiquement pendant le processus de construction de JMRI &#224; partir des
      annotations dans les fichiers sources.
      JMRI les regroupe ensuite dans le niveau appropri&#233; du fichier <code>jmri.jar</code>, 
      o&#249; ils seront finalement trouv&#233;s et o&#249; l'on agira.
      
      <p>
      Pour y acc&#233;der :
<pre style="font-family : monospace ;">
            java.util.ServiceLoader.load(OurServiceClass.class).forEach((ourServiceObject) -> {
                 // acc&#233;der &#224; l'objet de service via notreServiceObject
            }) ;
</pre>
 Derni&#232;re traduction 2021-02-01
      <!--#include virtual="/Footer.shtml" -->
    </div><!-- closes #mainContent-->
  </div><!-- closes #mBody-->
</body>
</html>
