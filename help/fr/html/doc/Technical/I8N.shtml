<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- $Id$ -->
<!-- UpDated by Blorec Herv&#233; le 2020-12-17--> <html lang="fr">
<head>
    <TITLE>
 	JMRI: Internationalisation
    </TITLE>
    <META content="Bob Jacobsen" name="Author">
    <meta name="keywords" content="JMRI technical code I8N internationalization">

<!-- Style -->
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <link rel="stylesheet" type="text/css" href="/css/default.css" media="screen">
  <link rel="stylesheet" type="text/css" href="/css/print.css" media="print">
  <link rel="icon" href="/images/jmri.ico" type="image/png">
  <link rel="home" title="Home" href="/">
<!-- /Style -->
</head>
<body>
<!--#include virtual="/Header" -->
    <div id="mBody">
<!--#include virtual="Sidebar" -->

	<div id="mainContent">

<h1>JMRI: Internationalisation</h1>
	    	    
<P>
Les biblioth&#232;ques JMRI sont destin&#233;es &#224; &#234;tre utilisables dans le monde entier.
Pour ce faire, ils font usage des fonctionnalit&#233;s "internationalisation"
int&#233;gr&#233;es dans le langage Java et les biblioth&#232;ques.

<h2>Utilisation des Locales</h2>
<p>
JMRI utilise les param&#232;tres locaux par d&#233;faut pour localiser l'information d'internationalisation.
Cela signifie que JMRI pr&#233;sentera son interface utilisateur
dans le langage Java  d&#233;fini comme la valeur par d&#233;faut pour cet ordinateur.

<P>
Les locales sont sp&#233;cifi&#233;es par une Langue, et &#233;ventuellement un Pays. 
La langue est un code &#224; deux lettres minuscules; le pays est une code de deux
lettre majuscules. "en" est l'anglais, "fr" est le fran&#231;ais , "de" est l'allemand,
et "de_CH" est l'allemand parl&#233; en Suisse.
<P>
Lorsque Java cherche des ressources ( voir <a href="#resourcebundles"></a> ), il recherche d'abord
un fichier avec la Locale compl&#232;te en cours &#224; la fin de son nom
(foo_de_CH.properties, par exemple). Si cela &#233;choue, il tente un fichier
se terminant seulement par la localisation de la langue en cours : foo_de.properties.
Et si cela &#233;choue, il va &#224; la valeur par d&#233;faut sans suffixe: foo.properties.
Un m&#233;canisme similaire est utilis&#233; au sein des fichiers XML
.<P>
En installant les fichiers appropri&#233;s et en permettant &#224; l'utilisateur de s&#233;lectionner
la locale par d&#233;faut (dans le cadre des 
<a href="../../../package/apps/TabbedPreferences.shtml#locale"> pr&#233;f&#233;rences avanc&#233;es</a>),
nous pouvons adapter le programme aux diff&#233;rents pays et langues.

<a name="resourcebundles"><h2> Utilisation des Groupement de Ressources </h2>
Le texte pour les menus, boutons et les commandes similaires est contenu dans les
<strong>fichiers propri&#233;t&#233;s</strong>, qui sont accessibles via le m&#233;canisme de groupement* de ressources
de java.util.
<P>
Par exemple, le fichier de propri&#233;t&#233;s qui est utilis&#233; pour configurer le fichier
panneau contient des lignes telles que:
<PRE>
FieldRoadName       = Nom de Route:
</PRE>
A la gauche du signe &#233;gal est le nom de la ressource que le programme utilise
pour se r&#233;f&#233;rer &#224; la cha&#238;ne, &#224; droite du signe &#233;gal est la
cha&#238;ne qui sera affich&#233;e.
<p>
Par convention, les noms des &#233;l&#233;ments de ressource de l'interface graphique commence par l'un des termes
	<OL>
	<LI>Field - pour un champ visible, par exemple, libell&#233;, sur l'interface
	<LI>Button - pour un bouton de l'interface
	<LI>Menu - le nom en haut du menu 
	<LI>MenuItem - un &#233;l&#233;ment du menu(peut &#234;tre un &#233;l&#233;ment imbriqu&#233;)
	<LI>ToolTip - contenu d'une info-bulle
	<LI>Error - pour un message d'erreur affich&#233; dans le cadre de l'interface graphique
	</ol>
D'autres ressources sont nomm&#233;es afin de ne pas entrer en conflit avec celles-ci.
<p>Plusieurs noms standard pour les boutons, les objets, les couleurs, etc. sont regroup&#233;s en un seul endroit, &#224; partir duquel
ils sont disponibles dans tous les outils, tableaux et applications JMRI. L'offre group&#233;e de plus haut niveau est appel&#233;e
    <em>NamedBeanBundle</em>, situ&#233; dans le paquet jmri. Le niveau suivant se trouve dans le r&#233;pertoire jmri.jmrit (Outils),
o&#250; l'ensemble Bundle.properties contient des cl&#233;s communes &#224; tous les outils, comme les noms des couleurs et
autres cha&#238;nes de l'interface des outils.</p>

<H2>S'adapter &#224; un nouvelle langue</h2>
(
Les principales &#233;tapes pour adapter JMRI &#224; une nouvelle langue sont les suivantes:
	<OL>
	<LI> Cr&#233;er de nouvelles versions des fichier .properties pour changer la langue
	des contr&#244;les d'interface graphique.
	<LI>Traduire les fichiers XML pour les d&#233;codeurs, programmateurs et configuration.
	<LI>Traduire les fichiers d'aide et autres pages web.
	</OL>
<P>
Obtenir une copie propre du code source depuis le r&#233;f&#233;rentiel source JMRI.
(Pour plus d'informations pour le faire , Svp voir la 
<A HREF="getgitcode.shtml">page sur l'obtention d'une copie du code</a>.)

<h3> Traduction des Fichiers Properties </h3>
Si elles n'existent pas d&#233;j&#224;,
commencer par faire des copies des fichiers properties avec un suffixe pour votre
nouvelle langue. Sur un Mac OS X ou une machine Unix, ce sera:
<PRE>
   cd java/src/apps
   cp AppsBundle.properties AppsBundle_xy.properties
</PRE>
et ainsi de suite.
La meilleure fa&#231;on de trouver les suffixes appropri&#233;s consiste &#224; d&#233;finir le
programme de votre Langue particuli&#232;re via les
<a href="../../../package/apps/AppConfigPanel.shtml"> pr&#233;f&#233;rences avanc&#233;es </a>,
--&gt;Affichage --&gt; et onglet Langue, quitter et red&#233;marrer le programme,
et puis regarder le suffixe que le module JMRI affiche adans l'&#233;cran de d&#233;marrage/fen&#234;tre principale ( ligne du 
bas, entre les crochets apr&#232;s la version Java )..
Vous pouvez &#233;galement consulter la 
<a liste de href="http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt">liste officielle des langues </a>
(premi&#232;re partie du suffixe) et
<a href="http://www.iso.org/iso/country_codes/iso_3166_code_lists/english_country_names_and_code_elements.htm">liste 
des pays/r&#233;gions</a>
(deuxi&#232;me partie optionnelle du suffixe).
<p>
Vous pouvez ensuite modifier les fichiers dans une langue sp&#233;cifique pour saisir du texte dans dans votre propre langue.
<p>
Les lignes dans le fichier qui contiennent quelque chose comme <code>$Release: $;</code>
sont des vestiges des vieux syst&#232;mes de contr&#244;le de version; elles peuvent &#234;tre ignor&#233;es ou effac&#233;es. 
<P>
Ils y a plusieurs fichiers .properties* qui sont utilis&#233;s qui sont utilis&#233;s pour des contr&#244;les internes,
et ne doivent pas &#234;tre traduit. Ils sont marqu&#233;s par un commentaire en haut
du fichier. Un exemple est le fichier <code>apps/AppsStructureBundle.properties</code>

<a name="commonkeys"></a><p>
Nous vous conseillons de commencer une nouvelle traduction en compl&#233;tant les liasses de niveau le plus &#233;lev&#233;, en commen&#231;ant par la
<em>NamedBeanBundle</em> dans le r&#233;pertoire src/jmri finissez de descendre dans la hi&#233;rarchie des dossiers, en suivant bien s√ªr votre
int&#233;r&#234;t pour certains modules. En suivant cet ordre, vous verrez votre travail initial tout au long de l'interface utilisateur pour des outils tels que
Panneaux, op&#233;rations et signaux.<br>
Gr&#226;ce &#224; la hi&#233;rarchie des fichiers de propri&#233;t&#233;s des paquets, nous maintenons une coh&#233;rence dans l'interface utilisateur des diff&#233;rentes parties. 
Si vous rencontrez un point pour lequel votre langue ne fonctionne pas, veuillez laisser une note aux d&#233;veloppeurs afin que nous puissions 
vous aider en ajoutant une cl&#233; sp&#233;cifique, ou m&#234;me en divisant l'arborescence.</p>

<h3>Traduction des Fichiers XML</h3>
<p>Le dossier <code>xml/config/parts/jmri/</code> contient des chaines de texte suppl&#233;mentaires pour traduire pour les programmeurs etc. 
Juste comme dans <a href="#xml">fichier d&#233;codeur XML</a>, les chaines traduites sont ins&#233;r&#233;es comme des &#233;l&#233;ments 
<code>&lt;name xml:lang="da"&gt;Votre Traduction&lt;/name&gt;</code> dans chaque n&#339;ud.
Nous fournissons une <a href="XmlEditors.shtml">liste d'&#233;diteurs</a> pour travailler efficacement sur ces fichiers

<h3> v&#233;rifier votre travail</h3>
<OL>
<LI> Reconstruisez votre copie du programme, c'est-&#224;-dire avec votre <a href="index.shtml#buildyourcopy">IDE</a> ou de toute autre mani&#232;re.
<LI> Lancez le programme et s&#233;lectionnez "Pr&#233;f&#233;rences" dans le menu Edition
<LI> Cliquez sur l'onglet <b>Affichage</b> &#224; gauche, et sur l'onglet <b>Langue</b> dans le panneau de droite ;
<LI> S&#233;lectionnez votre langue dans la liste d&#233;roulante (n'oubliez pas qu'une fois que vous avez lanc&#233; JMRI dans une autre Locale,
        la liste des langues sera &#233;galement traduite dans cette langue, en changeant l'ordre
        pour par exemple &quot;Anglais&quot ; au lieu de &quot;English&quot; ;
<LI> Cliquez sur "Enregistrer", quitter et red&#233;marrer
<li> Vous devez imm&#233;diatement voir les articles que vous avez traduit.
</OL>
<P>
S'il ya un probl&#232;me &#224; ce stade, v&#233;rifier pour voir quel est le langage
figurant sur l'&#233;cran de d&#233;marrage de l'application.
Montre-t-il le m&#234;me suffixe (par exemple _fr ou _cs_CZ) que celui donn&#233;
donn&#233; &#224; vos fichiers? Le suffixe que le programme utilise est d&#233;termin&#233;
par la locale s&#233;lectionn&#233; dans les pr&#233;f&#233;rences ci-dessus.
<P>
Pour mettre votre travail &#224; la disposition des autres utilisateurs de JMRI, veuillez &#224; le partagez avec nous <a href="index.shtml#contributing">contribuez via GitHub</a>.
En utilisant une demande d'extraction GitHub, il est facile pour nous de fusionner vos nouvelles et/ou modifi&#233;es
dans le d&#233;p&#244;t de code. En cas de probl&#232;me, n'h&#233;sitez pas &#224; 
demander de l'aide &#224; ce sujet.

<h4>Caract&#232;res non romains</h4>
<p>Les langues qui impliquent des lettres non romaines n&#233;cessitent une
une attention particuli&#232;re. Les fichiers .properties doivent contenir uniquement
Caract&#232;res ISO 8859-1.  Si vous souhaitez utiliser des caract&#232;res Unicode, 
il faut les &#233;vacuer manuellement.  
Veuillez consulter le 
<a href="https://web.archive.org/web/20030217222249/http://java.sun.com/j2se/1.3/docs/guide/intl/faq.html">Java internationalization FAQ</a>
pour plus d'informations sur la mani&#232;re d'inclure ces caract&#232;res dans vos fichiers .properties, en particulier la
question sur "Comment puis-je sp&#233;cifier des cha&#238;nes de caract&#232;res non ASCII dans un fichier de propri&#233;t&#233;s ?
<p> Un exemple est le 
<a href="https://github.com/JMRI/JMRI/blob/master/java/src/apps/AppsBundle_cs.properties">java/src/apps/AppsBundle_cs.properties</a> 
qui contient des lettres diacritiques pour la traduction tch&#232;que. 
<L'outil "<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#intl">native2ascii</a>" peut vous aider dans ce domaine
en convertissant les caract&#232;res sp&#233;ciaux en s&#233;quences correctes, mais vous devez y faire passer vos fichiers avant de les soumettre &#224; JMRI.
Les caract&#232;res sp&#233;ciaux sont quelque peu sp&#233;cifiques &#224; la machine, donc pour qu'ils soient correctement trait&#233;s, ils doivent &#234;tre convertis en
S&#233;quences ISO 8859-1 sur votre ordinateur avant la soumission.

<a id="xml"> <h3>Traduction Fichiers XML</h3>
Les fichiers XML peuvent &#233;galement &#234;tre internationalis&#233;s. Il y a des exemples dans le r&#233;pertoire des d&#233;finitions de d&#233;codeurs
. Regardez  les &#233;l&#233;ments avec un attribut xml: lang = "fr"
attribut. Fondamentalement, vous cr&#233;ez des &#233;l&#233;ments suppl&#233;mentaires &#224; cet attribut pour
sp&#233;cifier la langue utilis&#233;e:
<pre style="font-family: monospace;">
      &lt;variable CV="6" default="22" item="Vmid"&gt;
        &lt;decVal max="64"/&gt;
        &lt;label&gt;Vmid&lt;/label&gt;
        &lt;label xml:lang="fr"&gt;Vmoy&lt;/label&gt;
      &lt;/variable&gt;
</pre>
<p>
Dans les fichiers XML, les attributs de "l'&#233;l&#233;ment" doivent rester non traduit, comme le
fait la totalit&#233; du fichier xml/names.xml.

<p>
Il existe des transformations XSLT qui permettent d'ins&#233;rer des &#233;l&#233;ments de langue par d&#233;faut
dans les dossiers.  Ils ont toujours un contenu en anglais, mais 
il est peut-&#234;tre plus facile de se contenter de traduire un texte anglais que de 
modifier les nouveaux &#233;l&#233;ments XML, s'assurer que la structure est correcte, etc.
Pour plus d'informations, voir le fichier <a href="https://jmri.org:/xml/XSLT/I18N">xml/XSLT/I18N</a>
ou demandez sur la liste des d&#233;veloppeurs de jmri.

<a id="help"> <h3> Traduire les Fichiers d'Aide </h3>
(Cela n'a &#233;t&#233; fait qu'une fois, aussi ces instructions peuvent ne pas &#234;tre compl&#232;tes)
<p>
Les fichiers d'aide en anglais se trouvent dans le r&#233;pertoire help/en.
Si vous voulez cr&#233;er un ensemble complet de fichiers:
<ul>
li>Cr&#233;er une copie des fichiers existants &#224; partir de l'aide/en
dans un nouveau r&#233;pertoire help/LL, o&#250; LL est le code de la langue
 pour votre langue, par exemple help/fr. (Attention, il se fait 
 directement dans GitHub, et demander l'aide d'un d&#233;veloppeur si n&#233;cessaire)
<li>Renommez le fichier <code>help/fr/JmriHelp_fr.hs</code> dans la copie 
que vous venez de cr&#233;er en <code>help/fr/JmriHelp_fr.hs</code>
<li>Editez le <code>help/fr/format.xsl</code> pour cr&#233;er une balise <code>&lt;HTML LANG="fr"&gt;</code>.
<li>Traduisez tous les fichiers .shtml dans le r&#233;pertoire help/fr/. Ne pas traduire
tous les fichiers <code>.xml</code> et <code>.jhm</code> ou les fichiers <code>web*.shtml</code> dans le r&#233;pertoire help/LL/ du haut, car ils
sont produits automatiquement.
</ul>

<a name="dev"> <h2>Internationalisation pour les D&#233;veloppeurs</h2>

Pour que l'internationalisation fonctionne, vous devez faire quelques choses dans le code que
vous &#233;crivez. Quelques r&#233;f&#233;rences Web sur la fa&#231;on de le faire:
<UL>
<li> <a HREF="http://java.sun.com/docs/books/tutorial/i18n/index.html">tutoriel Sun internationalisation </a>(fortement recommand&#233;)
<li> <a HREF="http://java.sun.com/j2se/1.3/docs/guide/intl/faq.html">page  principale Java Internationalisation </a>
</Ul>
<strong>Note: Ce sont 6 liens Java. Il y a des fonctionnalit&#233;s avanc&#233;es utiles dans
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/intl/enhancements.7.html">Java 7</a> et
<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/intl/enhancements.8.html">Java 8</a>.</strong>
<P>
JMRI se dirige vers un ensemble de conventions sur la fa&#231;on de structurer et
utiliser la grande quantit&#233; d'informations I18N n&#233;cessaire.
Vous pourrez toujours trouver le code avec des approches plus anciennes, mais vous
devrez &#233;crire un nouveau code &#224; l'aide des nouvelles conventions d&#233;crites ci-dessous

<p>
Les groupements des ressources JMRI sont organis&#233;es dans un arbre hi&#233;rarchis&#233;.
Par exemple, le code dans le paquet <code>jmri.jmrit.display</code> 
peut trouver une ressource dans un groupement dans le paquet <code>jmri.jmrit.display</code>, le paquet 
<code>jmri.jmrit</code>
ou enfin le paquet <code>jmri</code>. Comme un cas particulier dans ce domaine, le paquet <code>apps*</code> est
consid&#233;r&#233; comme &#233;tant en dessous du paquet <code>jmri</code> lui-m&#234;me, de sorte que le code dans 
l'arborescence des <code>apps*</code> 
peut aussi r&#233;f&#233;rencer le paquet <code>jmri</code>.
<p>
Les r&#233;f&#233;rences crois&#233;es-paquet, par exemple  entre <code>jmri.jmrit</code> et <code>jmri.jmrix</code>, sont d&#233;courag&#233;es
et celles qui existent sont supprim&#233;es.
<p>
L'acc&#232;s se fait via une classe groupement locale pour chaque paquet. Une caract&#233;ristique est une
<code><href="http://jmri.org/JavaDoc/doc/jmri/jmrit/Bundle.html"> jmri.jmrit.Bundle</a></code>.
Il propose deux m&#233;thodes cl&#233;s &#225; utiliser pour acc&#233;der (traduit) &#224; la chaine ressource:<br>
<code>
static String <B>getMessage</B>(String&nbsp;key)

static String <B>getMessage</B>(String&nbsp;key, Object ... &nbsp;subs)</code>

<p>
La premi&#232;re offre un acc&#232;s direct &#224; une cha&#238;ne via <P>
<code> String msg = Bundle.getMessage ("Titre")</code>.
<p>
La seconde permet d'ins&#233;rer des informations sp&#233;cifiques dans un message du genre
<br> <code>Nom Syst&#232;me LT1 est d&#233;j&#224; utilis&#233;</code>
<P>
Ici "LT1" ne peut pas &#234;tre dans le fichier .properties, car il n'est connu seulement que
lorsque le programme est ex&#233;cut&#233;. Diff&#233;rentes langues
peuvent mettre cette partie du message dans diff&#233;rents endroits, et accepter que
se soit important.
Cela a abouti &#224; mettre un espace r&#233;serv&#233; dans la d&#233;finition du message:
<pre><code>
Error123 = Nom syst&#232;me {0} est d&#233;j&#224; en cours d'utilisation
</code></pre>
(Vous pouvez avoir plus d'une insertion, appel&#233;e {1}, {2}, etc)
<P>
Ensuite, formater le message final en ins&#233;rant le contenu en elle:
<pre> <code>
   String msg = Bundle.getMessage ("Erreur123", badname);
</code> </pre>
<P>
Le premier argument est la cl&#233; du message
suivie par une ou plusieurs cha&#238;nes de caract&#232;res &#224; ins&#233;rer dans le message.
(C'est mieux que de
cr&#233;er votre propre cha&#238;ne de sortie en utilisant par exemple String.format () car elle permet
aux termes ins&#233;r&#233;s d'appara&#238;tre dans des ordres diff&#233;rents dans diff&#233;rentes langues.)
<P>
Diff&#233;rentes langues peuvent avoir besoin d'un nombre diff&#233;rent de lignes pour exprimer
un message, ou peut-&#234;tre besoin de le casser avant ou apr&#232;s qu'une valeur particuli&#232;re
ait &#233;t&#233; ins&#233;r&#233;e. Il est donc pr&#233;f&#233;rable d'utiliser "\n" dans un
un message unique pour cr&#233;er des sauts de ligne, plut&#244;t
que de fournir plusieurs lignes dans le code lui-m&#234;me.
<p>
Certaines parties de JMRI restent en Anglais en raison de notre population de d&#233;veloppeurs.
En particulier, des commentaires et des noms de variables dans le code doivent rester en
Anglais, comme les messages envoy&#233;s sur le syst&#232;me de rapport.
Dans le code Java, ces cha&#238;nes peuvent &#234;tre marqu&#233;s avec un un commentaire "<code>// NOI18N</code>"
 ajout&#233; &#224; la fin de la ligne. Si n&#233;cessaire, mettre ceci apr&#232;s un autre commentaire:
<pre style="font-family: monospace;">
           Sensor thisSensorVariableNameIsInEnglish;

           String message = "THAT_ONE_MESSAGE";  // NOI18N
           JLabel jl1 = new JLabel(Bundle.getMessage(message));

           JLabel jl2 = new JLabel(Bundle.getMessage("LABELKEY"));  // NOI18N

           log.debug("The process failed account of user error"); // NOI18N
         
           // Ce commentaire est en anglais et ne doit pas &#234;tre annot&#233; w.r.t. internationalization

<h4> Ajout d'un nouveau Bundle* </h4>

Si votre paquet ne poss&#232;de pas d&#233;j&#224; une classe Bundle*, vous pouvez l'ajouter par:
<ul>
<li>Copiez la classe Bundle <code>java/src/jmri/jmrit/Bundle.java</code> dans votre paquet comme: 
<code>java/src/jmri/mypackage/Bundle.java</code>
<li> Modifier ce nouveau fichier dans trois endroits:
<ol>
<li> La d&#233;claration "package" en haut devrait inscrire votre paquet
<li> La "class ... extends "devrait se r&#233;f&#233;rer &#224; la classe Bundle directement au-dessus de votre paquet
<li> L'affectation de la variable "name" doit &#234;tre le nom de votre bundle locale, par convention &quot;jmri/mypackage.Bundle&quot;.
</ol>
<li> Cr&#233;er un nouveau fichier <code>Bundle.properties</code> dans votre r&#233;pertoire package
     pour contenir vos propri&#233;t&#233;s de cha&#238;nes de caract&#232;res.
<li> Id&#233;alement, vous allez ajouter une copie de <code>java/test/jmri/jmrit/BundleTest.java</code> &#224; votre
     R&#233;pertoire de test JUnit pour v&#233;rifier que vos cha&#238;nes fonctionnent:
<br> Copiez <code>java/test/jmri/jmrit/BundleTest.java</code> dans <code>java/test/jmri/mypackage/BundleTest.java</code>
     suivie de la modification de la d&#233;claration de votre paquet dans ce fichier pour pointer vers votre
     paquet, en ajoutant un peu de vos cha&#238;nes pour les tests (y compris ceux que vous
     r&#233;f&#233;rencez &#224; partir des bundles parents, le cas &#233;ch&#233;ant), et incluant une r&#233;f&#233;rence
     dans votre classe PackageTest.
</ul>

<h4>Ancien code </h4>
L'ancien code r&#233;f&#233;rence directement les Bundles :

<pre> <code>
   java.util.ResourceBundle.getBundle ("jmri.jmrit.beantable.LogixTableBundle");
</code> </pre>

<P>
L'argument getBundle est le nom du paquet complet (non pas le fichier)
pour le fichier propri&#233;t&#233; de cette classe qui sera utilis&#233;. Vous pouvez avoir &#224;
r&#233;f&#233;rencer plus d'un de ces objets si vous voulez regarder les
cha&#238;nes dans plus d'un fichier properties.

<P>
Vous pouvez ensuite r&#233;cup&#233;rer des cha&#238;nes particuli&#232;res comme ceci:
<pre> <code>
java.util.ResourceBundle.getBundle ("jmri.jmrit.beantable.LogixTableBundle") getString ("ButtonNew").;
</code> </pre>
<P>
Nous vous recommandons de ne d&#233;finir qu'une variable de classe statique pour maintenir la
r&#233;f&#233;rence &#224; l'objet Bundle, cela finit par consommer beaucoup
de m&#233;moire permanente dans un programme de la taille de JMRI. Allez-y et
appeler le <code>getBundle ()</code> &#224; chaque fois, c'est rapide, car il fonctionne &#224; travers
un cache faiblement r&#233;f&#233;renc&#233; et nettoyeur de la m&#233;moire.
<p>

<a name="xml-dev" id="xml-dev"></a>
<h3>Acc&#232;s XML</h3>
Deuxi&#232;mement, vous devez r&#233;cup&#233;rer correctement des &#233;l&#233;ments et attributs XML .
Le jmri.util.jdom.LocaleSelector fournit une m&#233;thode getAttribute (...)
qui remplace l'&#233;l&#233;ment de getAttribute JDOM lorsque le contenu de l'
attribut aurait pu &#234;tre internationalis&#233;. Vous pouvez l'utiliser comme ceci:

<code> <pre>
String choice = LocaleSelector.getAttribute (choiceElement, "choice")
</pre> </code>
o&#249; "choiceElement" est un objet Element JDOM contenant un (Traduction possible)
attribut  "choix". &quot;Null&quot; sera retourn&#233; si rien n'est trouv&#233;.

<a name="numbers" id="numbers"></a>
<h3>Nombres</h3>
<p>Les nombres "10*10*10+2+3/10" est &#233;crit dediff&#233;rentes mani&#232;res en des emplacements diff&#233;rents:
"1002,3",
"1,002.3",
" 1.002,3" et peut-&#234;tre d'autres choses
<p>
JMRI fournit un utilitaire utile pour manipuler ceux-ci sur l'entr&#233;e:

<code><pre>
   double d = jmri.util.IntlUtilities.doubleValue("1,002.3");
   float  f = jmri.util.IntlUtilities.floatValue("1,002.3");
</pre></code>

Notez que cela peut lancer une <code>java.text.ParseException</code> si l'entr&#233;e est imparable, ce qui fait partie de la gestion des erreurs de l'utilisateur.

<p>
Pour la production :
<pre style="font-family : monospace ;">
   Cha&#238;ne s = jmri.util.IntlUtilities.valueOf(1002.3) ;
</pre>
<p>
<strong>Note : Vous devez toujours stocker et charger les valeurs dans les fichiers XML dans le codage par d&#233;faut de Java,
sans utiliser ces outils de formatage. De cette fa&#231;on, les fichiers peuvent &#234;tre d&#233;plac&#233;s
d'un utilisateur &#224; l'autre sans se soucier de savoir s'ils utilisent le m&#234;me Locale.</strong>

 
<a name="testing" id="testing">
<h3> Test </h3>

Vous devez v&#233;rifier que vous avez correctement internationalis&#233;
votre code. Nous fournissons un outil pour le faire ce qui cr&#233;e
et traduit automatiquement la version de vos fichiers properties,
suivant les id&#233;es de Harry Robinson et Arne Thormodsen.
(Leur
<a href="http://www.oocities.org/harry_robinson_testing/klingon.htm" papier sur ceci</a> est une lecture recommand&#233;e!)
Pour l'utiliser:
<ul>
<li> Assurez-vous que votre code se compile et se construit bien dans votre <a href="index.shtml#buildyourcopy">IDE</a>. Nous modifierons 
la version compil&#233;e.
<li> Ex&#233;cuter le script "translate.sh" dans votre r&#233;pertoire de construction java/. Cela cr&#233;e de nouveaux fichiers 
properties, temporaires dans l'arbre r&#233;pertoire classes/. Vous devrez refaire ceci
chaque fois que l'arbre classes/ est enlev&#233; par exemple par "ant clean" ou une construction<a href="index.shtml#buildyourcopy">IDE</a> .
<li>Effacez le fichier Preferences, ou modifiez le pour enlever la ligne de d&#233;finition GUI
<li> Ex&#233;cutez DecoderPro via "Ant locale", qui d&#233;marre le programme DecoderPro
en utilisant les nouveaux fichiers de propri&#233;t&#233;s.
</ul>
Si tout va bien, tout le texte du message aura &#233;t&#233; traduit en MAJUSCULES.
Tout ce que vous avez &#233;crit et qui reste en minuscules n'a pas &#233;t&#233; compl&#232;tement internationalis&#233;.
<a name="bundlekeysreport"></a>
<h3>Rapport sur les cl&#233;s group&#233;es</h3>
<p><strong>BundleKeysReport.py</strong>, situ&#233; dans le r&#233;pertoire <strong>scripts</strong> (pas jython),
est utilis&#233; pour analyser les cl&#233;s de regroupement au sein d'un fichier de propri&#233;t&#233;.  La fonction principale est
d' identifier les cl&#233;s non utilis&#233;es.  Le script est ex&#233;cut&#233; en utilisant <strong><em>PanelPro Panels >>
Ex&#233;cuter le script...</em></strong> La sortie du script est &#233;crite dans la fen&#234;tre de sortie du script.   La dur&#233;e d'ex&#233;cution varie en fonction du nombre de cl&#233;s &#224; v&#233;rifier
ainsi que la position dans la hi&#233;rarchie des sources.  Il s'agira de plusieurs
secondes.</p>
<p>Une fois qu'un fichier de propri&#233;t&#233;s, normalement le fichier par d&#233;faut/anglais, est s&#233;lectionn&#233;, toutes les classes du paquet sont analys&#233;es pour chaque cl&#233; du fichier. s'il y a
plus de paquets en dessous du paquet initial, leurs classes sont &#233;galement scann&#233;es.  Ceci
couvre la hi&#233;rarchie des lots. <strong>Note:</strong> Il est possible d'obtenir des correspondances faussement positives lorsqu'une classe utilise une cl&#233; de correspondance mais que la classe utilise un
fichier de propri&#233;t&#233; priv&#233;e.</p>

<p>Apr&#232;s la construction de la liste des cl&#233;s inutilis&#233;es, l'arbre des sources est enti&#232;rement analys&#233; &#224; la recherche 
des r&#233;f&#233;rences au dossier de propri&#233;t&#233; s&#233;lectionn&#233;.  Si la classe contenant la r&#233;f&#233;rence utilise
les cl&#233;s inutilis&#233;es, ces cl&#233;s sont retir&#233;es de la liste des cl&#233;s inutilis&#233;es.  Le jython
est &#233;galement analys&#233; pour les r&#233;f&#233;rences externes.

<p>Une fois le balayage termin&#233;, une bo&#238;te de dialogue vous invite &#224; enregistrer la liste des cl&#233;s inutilis&#233;es.  Si
souhait&#233;e, la liste sera r&#233;dig&#233;e avec le lieu et le nom s&#233;lectionn&#233;s.
L'emplacement par d&#233;faut sera l'emplacement des fichiers de l'utilisateur (User Files Location.</p>

<p>La derni&#232;re bo&#238;te de dialogue demande si les fichiers de propri&#233;t&#233; doivent &#234;tre mis &#224; jour.  Si oui, c'est 
s&#233;lectionn&#233;, tous les fichiers de propri&#233;t&#233; de l'ensemble sont sauvegard&#233;s.  Chaque fichier est alors
 scann&#233; pour les cl&#233;s non utilis&#233;es.  Lorsqu'une cl&#233; est trouv&#233;e, la ligne est mise &#224; jour avec
<strong>#NotUsed</strong> en commentaire.  Si les tests r&#233;v&#232;lent que la cl&#233; est
effectivement requise, le commentaire peut &#234;tre supprim&#233;.  <strong>Note:</strong> <em>Si
l'arbre des sources est g&#233;r&#233; par Git, les sauvegardes seront incluses dans la
 branche actuelle.  D&#233;placez les sauvegardes ou ne les s&#233;lectionnez pas lorsque vous faites un commit</em>.

<a name="classkeysreport"></a>
<h3>Rapport sur les cl&#233;s de classe</h3>
<p><strong>ClassKeysReport.py</strong>, situ&#233; dans le r&#233;pertoire <strong>scripts</strong> (pas jython),
est utilis&#233; pour identifier les cl&#233;s de paquets utilis&#233;es par une classe. Le script est ex&#233;cut&#233; en utilisant
<strong><em>PanelPro Panels >> Run Script...</em></strong>
Le script de Sortie est &#233;crit dans la fen&#234;tre de sortie du script.</p>

<p>Lorsque le script est lanc&#233;, un dialogue de s&#233;lection de fichier s'affiche.  S&#233;lectionnez soit
un fichier de classe Java ou un r&#233;pertoire de paquets Java.  Si un r&#233;pertoire est s&#233;lectionn&#233;, tous les
 fichiers *.java dans le r&#233;pertoire seront trait&#233;s.  Le fichier Bundle.java
est exclue.

<p>Pour chaque fichier, le script recherche <strong>Bundle.getMessage(</strong> et 
<strong>getString(</strong>.  Le premier <strong><em>word</em></strong> apr&#232;s 
la parenth&#232;se est retourn&#233;e comme cl&#233; de liasse.  Un mot est d&#233;fini comme les caract&#232;res
a-z, A-Z, 0-9 et soulignement.  Si le premier mot est une r&#233;f&#233;rence locale, le
le deuxi&#232;me mot est renvoy&#233;.</p>

<p>Voici une ligne de sortie typique:</p>
<pre style="font-family : monospace ;">
   783, Type de recherche = local, Type de cl&#233; = variable, Cl&#233; = 'titleId',<br>
         Texte = addLogixFrame = nouveau JmriJFrame(rbx.getString(titleId)) ;
</pre><!-- without <br> does not reflow on iPad when viewd online, causing rest of the page to shrinkk-->
Liste des champs
<ul>
    <li>Le num&#233;ro de la ligne de code source</li>
    <li>Type de recherche
        <ul>
            <li>Local : getString, tel que rbx.getString()</li>
            <li>Bundle : getMessage()</li>
        </ul>
    </li>
    <li>Type de cl&#233;
        <ul>
            <li>String : Un <strong>mot</strong> entour&#233; de guillemets</li>
            <li>Variable : Un simple <forte> mot</strong></li>
        </ul>
    </li>
    <li>La cl&#233;</li>
    <li>La ligne du code source</li>
</ul>
<p>Seul les types de cl&#233;s variables sont affich&#233;s dans la fen&#234;tre de sortie du script.<br>
<strong>Note</strong> : Une cl&#233; qui contient des caract&#232;res non textuels sera tronqu&#233;e
et on lui a attribu&#233; le type de cl&#233; variable.
</p>

<p>Lorsque le script a &#233;t&#233; scann&#233;, il offre une option permettant d'exporter le  <strong>r&#233;sultat</strong>
&#224; un fichier CSV.</p>
  <!--#include virtual="/Footer.shtml" -->
	  </div><!-- closes #mainContent-->
	</div> <!-- closes #mBody-->
</body>
</html>
