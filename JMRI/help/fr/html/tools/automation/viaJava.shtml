<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html lang="fr">
<head>
<!-- Copyright Bob Jacobsen, John Plocher 2005, 2006, 2008 -->
<!-- Translated by Herv&#233; Blorec le 2016/09/09-->
<title>JMRI: Layout Automation in Java</title>

<!-- Style -->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="/css/default.css" media="screen">
<link rel="stylesheet" type="text/css" href="/css/print.css" media="print">
<link rel="icon" href="/images/jmri.ico" TYPE="image/png">
<link rel="home" title="Home" href="/">
<!-- /Style -->
</head>

<body>
<!--#include virtual="/Header" -->

<!--#include virtual="Sidebar" -->
<div id="mainContent">


<!-- Page Body -->
<H2>JMRI: Automatisation R&#233;seau en Java</h2>

La biblioth&#232;que JMRI fournit un ensemble puissant d'outils pour
automatiser votre r&#233;seau. Si les outils int&#233;gr&#233;s &#224;
<A HREF="../../apps/PanelPro/PanelPro.shtml"> PanelPro</a> ou les
<A HREF="../scripting/index.shtml"> capacit&#233;s de scripts</a>
ne sont pas suffisantes pour faire ce que vous voulez, la solution sera d'&#233;crire vous-m&#234;me vos propres
programme de commande.

<p> Cette page d&#233;crit les classes Java qui ont en charge l'&#233;criture
"Automatisation" JMRI du code en Java. C'est des choses comme les
signaux d'exploitation, les trains, et m&#234;me des choses subtiles comme
l'&#233;volution du volume du son du d&#233;codeur quand un train passe dans un tunnel.</p>

<p>
Notez que vous pouvez aussi &#233;crire votre code d'automatisme en utilisant Jython 
comme <a href="../scripting/index.shtml">"scripts" JMRI </a>. 
Pour plusieurs raisons, ceci peut &#234;tre plus simple 
parce qu'il plus r&#233;actif et a un meilleur support de d&#233;bogage.
Java est r&#233;ellement le meilleur pour les cas longs et complexes, ou si vous &#233;crivez 
quelque chose que vous voulez finalement voir contribuer &#224; JMRI lui-m&#234;me.
</P>

<dl>
<dt class=left> Introduction</dt>
<dd class=first> 
<p> La classe"Automat" fournit un moyen facile d'&#233;crire l'automatisation par Java
pour votre r&#233;seau en utilisant JMRI.</p>

<p> La classe cl&#233; est
<A    HREF="http://jmri.org/JavaDoc/doc/jmri/jmrit/automat/AbstractAutomaton.html">AbstractAutomaton</a>,
qui fournit un  support de liaison  pour simplifier le code d'automatisation personnalis&#233;.</p>

<p>Aspect essentiel:  Ceux-ci  s'ex&#233;cutent dans un lien s&#233;par&#233;, de sorte qu'ils peuvent attendre 
que quelque chose se produise pour que le reste du  programme continue.
Effectivement, chaque Automat est un programme distinct s'ex&#233;cutant quand il le
doit.

<p> Il y a plusieurs exemples:
<ul>
<li> SampleAutomaton - surveille un capteur, et ajuste l'
&#233;tat d'un aiguillage afin qu'il corresponde &#224; l'&#233;tat du Capteur.
<li> SampleAutomaton2 - surveille un capteur, et ajuste
le mouvement d'un d&#233;codeur de locomotive utilisant le mode de programmation mode ops 
lorsque l'&#233;tat du capteur change.
<li> SampleAutomaton3 - une locomotive fonctionne en avant et en arri&#232;re
sur un morceau de voie en regardant deux capteurs, inversant la locomotive
quand ils changent d'&#233;tat.
</Ul></p>

<p>Notez qu'ils ne peuvent rien faire d'utile sur votre
r&#233;seau, car ils ont les num&#233;ros de Loco qui ne sont pas modifiables.
Ils sont cens&#233;s &#234;tre des exemples pour votre propre programmation, pas des outils 
utiles.
</Dd>

<dt class=left>Commande de Locomotives</dt>
<dd>
<p class=example>
// R&#233;cup&#232;re l'instance du r&#233;gulateur  pour l'"adresse courte" 3 <br>
throttle = getThrottle (3, false);
</P>

<p> Cet extrait de code assigne "adresse courte 3" &#224; la variable "r&#233;gulateur" 
 ( le "false" s&#233;lectionne l'adresse courte; "true" aurait
&#233;t&#233; pour l'adresse longue). Si cela ne fonctionne pas pour une raison quelconque, vous obtiendrez un 
message p&#233;riodique "toujours en attente de r&#233;gulateur" dans la fen&#234;tre de Java, et
le programme attendra.</p>
</Dd>

<dt class=left> Interaction avec l'utilisateur</dt>
<dd>
<p> Vous pouvez mettre en place des bo&#238;tes de message directement &#224; partir de Java, mais cela prend un peu de
code pour le faire. Pour simplifier, au d&#233;but, j'ai ajout&#233; une classe d'assistance "MsgFrame" 
&#224; la biblioth&#232;que JMRI.</P>

<p> Pour faire une bo&#238;te de message, vous devez d'abord faire un objet de la classe "MsgFrame":</p>
<p class=example>
MsgFrame box = nouveau MsgFrame ();
</P>

<p> (Vous pouvez appelez &#231;a comme vous voulez, bien s&#251;r). Cette ligne devrait aller
avec les autres d&#233;clarations, par exemple &#224; droite apr&#232;s la ligne "DccThrottle throttle=
null;. "</p>

<p> Puis, &#224; l'int&#233;rieur des routines de test, il y a quelques choses que vous pouvez faire. Pour
afficher un message et attendre que l'utilisateur clique sur un bouton "Continuer", faites: .

<p class=example>
box.show ("mon texte du message va ici", true);
</P>

<p> Le 2&#232;me argument montre le bouton "Continuer" et attend si elle est vraie, et
continue si elle est fausse. Donc, si vous souhaitez afficher un message d'&#233;tat pendant 
que le programme continue &#224; &#224; se d&#233;rouler, faire:</p>

<p class=example>
box.show ("text message d'&#233;tat", false);
</P>

<p> Si vous avez fait cela, vous pouvez modifier le message avec un autre "show", ou
vous pouvez faire partir la bo&#238;te avec:</p>

<p class=example>
box.hide ();
</P>

<p> Java a fait faire des travaux pour faire appara&#238;tre la bo&#238;te et la dessiner. Nous ne
voulons pas retarder le programme de test principal, donc j'ai &#233;crit cette classe d'aide
pour faire tout ce genre de travail en tant que 2i&#232;me plus faible priorit&#233;. Vous devriez &#234;tre capable
de mettre en place des messages sur l'&#233;cran sans ralentir consid&#233;rablement le fonctionnement
 (&#224; moins que le programme attende que le bouton "Continuer" soit press&#233; pour continuer,
bien s&#251;r). Et attendre que "Continuer" soit press&#233; ne fera pas arr&#234;ter l'ex&#233;cution
du reste du programme.</p>
</Dd>

<dt class=left>Ex&#233;cution de Votre Code</dt>
<dd>
Il y a deux fa&#231;ons de le faire: Rendre votre code Java disponible pour JMRI et l'appeler.
<p>
La mani&#232;re la plus simple pour rendre votre code accessible est de faire un fichier .jar et 
de le placer dans le r&#233;pertoire "lib" dans le r&#233;pertoire du programme JMRI.
Autrement, vous pouvez cr&#233;er un r&#233;pertoire "Classes", et compiler votre class Java &#224; l'int&#233;rieur.
Dans ce cas, il devrait se retrouver dans:

<code><pre>
classes/MyCode.class
</pre></code>

Si vous n'avez pas sp&#233;cifi&#233; de code dans votre paquet, ou

<code><pre>
classes/MyCode.class
</pre></code>

ou

<code><pre>
classes/jmri/jmrit/automat/SampleAutomaton.class
</pre></code>

comme un exemple de la fa&#231;on dont le code est stock&#233; dans un package sp&#233;cifique .
<p>
La mani&#232;re la plus simple pour appeler votre code est d'utiliser le support script de JMRI.
Ouvrir une fen&#234;tre Sortie Script  ( ainsi vous verrez les erreurs ) depuis le menu Panneaux,
puis une fen&#234;tre Entr&#233;e Script, entrez:

<code><pre>
MyCode().start()
</pre></code>

ou

<code><pre>
import jmri.jmrit.automat
jmri.jmrit.automat.SampleAutomaton().start()
</pre></code>

et appuyez sur Executer. La deuxi&#232;me ligne cr&#233;e une instance de votre class et lui dit de d&#233;marrer une ex&#233;cution.
<p>
Une fois que vous avez obtenu qu'il travaille, vous pouvez le mettre dans un petit fichier script 
et l'appeler au d&#233;marrage,  via un Logix ou autre chose.

</dd>


</dl>
<p>Retour &#224; la <a href="index.shtml">page d'Aide Automatisation</a>.

<!--#include virtual="/Footer" -->
    </div><!-- closes #mainContent-->
  </div> <!-- closes #mBody-->
</body>

</html>
